using Bridge.Html5;
using System;

namespace Bridge.WebGL
{
    /// <summary>
    /// WebGLRenderingContext objects expose the WebGLRenderingContext interface, the principal interface in WebGL which provides special properties and methods to manipulate the 3D content rendered in an HTML canvas element.
    /// The docs sources are:
    ///     https://www.khronos.org/registry/webgl/specs/1.0/
    ///     https://www.khronos.org/opengles/sdk/docs/man/
    ///     https://developer.mozilla.org/ru/docs/Web/API/WebGLRenderingContext
    ///     https://msdn.microsoft.com/en-us/library/ie/dn621085%28v=vs.85%29.aspx
    /// </summary>
    [External]
    public partial class WebGLRenderingContext
    {
        /// <summary>
        /// Specifies the active texture unit.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM - Texture isn't in the format of gl.TEXTUREi where i is within the range from 0 to gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS -1.
        /// </summary>
        /// <param name="texture">The texture unit to make active. Value is gl.TEXTUREi where i is in the range from 0 to gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS -1.</param>
        public virtual void ActiveTexture(int texture) { }

        /// <summary>
        /// Attaches a WebGLShader object to a WebGLProgram object.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION
        ///         If program isn't a program object.
        ///         If shader isn't a shader object.
        ///         If shader is already attached to program, or another shader object of the same type is already attached.
        ///
        ///     gl.INVALID_VALUE - If either program or shader isn't a value generated by WebGL.
        /// </summary>
        /// <param name="program">The WebGLProgram object created using the createProgram method. </param>
        /// <param name="shader">The WebGLShader object to attach.</param>
        public virtual void AttachShader(WebGLProgram program, WebGLShader shader) { }

        /// <summary>
        /// Binds a generic vertex index to a user-defined attribute variable.
        /// More than one name can be bound to the same vertex index, but multiple indexes cannot be bound to the same name.
        /// If name is a matrix attribute, then index points to the first column of the matrix. Additional matrix columns are automatically bound to index+1, index+2, and so forth based on matrix variable (mat2,mat3,mat4).
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If index is greater than or equal to gl.MAX_VERTEX_ATTRIBS.
        ///     gl.INVALID_VALUE        If program is not generated by WebGL.
        ///     gl.INVALID_OPERATION    If name starts with the reserved prefix gl_.
        ///     gl.INVALID_OPERATION    If program isn't a program object.
        /// </summary>
        /// <param name="program">Program object to bind. </param>
        /// <param name="index">The index of the generic vertex to bind. </param>
        /// <param name="name">me of the user variable to a bind to the generic vertex index.</param>
        public virtual void BindAttribLocation(WebGLProgram program, int index, string name) { }

        /// <summary>
        /// Associates a buffer with a buffer target.
        /// </summary>
        /// <param name="target">One of the following: gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER</param>
        /// <param name="buffer">A WebGLBuffer object to bind to target.</param>
        public virtual void BindBuffer(int target, WebGLBuffer buffer) { }

        /// <summary>
        /// Associates a WebGLFramebuffer object with the gl.FRAMEBUFFER bind target.
        /// The currently bound framebuffer is the target of drawing operations. If the framebuffer is null, the context reverts to the default framebuffer.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If target isn't gl.FRAMEBUFFER.
        /// </summary>
        /// <param name="target">The target the WebGLFramebuffer object is bound to. Must be gl.FRAMEBUFFER.</param>
        /// <param name="framebuffer">The WebGLFramebuffer object.</param>
        public virtual void BindFramebuffer(int target, WebGLFramebuffer framebuffer) { }

        /// <summary>
        /// Binds a WebGLRenderbuffer object to be used for rendering.
        /// Setting this to a null value effectively unbinds any previously bound WebGLRenderbuffer.
        /// When a buffer is bound to a target, the previously bound Renderbuffer for that target is automatically unbound.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM - If target isn't gl.FRAMEBUFFER.
        /// </summary>
        /// <param name="target">Set to gl.RENDERBUFFER.</param>
        /// <param name="renderbuffer">The name of the new WebGLRenderbuffer.</param>
        public virtual void BindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) { }

        /// <summary>
        /// Binds a named texture object to a target.
        /// Errors:
        ///     gl.INVALID_ENUM            If target isn't one of the listed values..
        ///     gl.INVALID_OPERATION    If texture was created with different target than target.
        /// </summary>
        /// <param name="target">gl.TEXTURE_2D or gl.TEXTURE_CUBE_MAP</param>
        /// <param name="texture">Either a reference to a texture object or null.</param>
        public virtual void BindTexture(int target, WebGLTexture texture) { }

        /// <summary>
        /// Specifies the blend color used to calculate source and destination blending.
        /// </summary>
        /// <param name="red">Red component in the range of 0-1.</param>
        /// <param name="green">Green component in the range of 0-1.</param>
        /// <param name="blue">Blue component in the range of 0-1.</param>
        /// <param name="alpha">Alpha (transparency) component in the range of 0-1.</param>
        public virtual void BlendColor(double red, double green, double blue, double alpha) { }

        /// <summary>
        /// Sets the equation used to blend RGB and Alpha values of an incoming source fragment with a destination values as stored in the fragment's frame buffer.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If mode is not one of the three possible values.
        /// </summary>
        /// <param name="mode">One of these values: gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT</param>
        public virtual void BlendEquation(int mode) { }

        /// <summary>
        /// Controls the blending of an incoming source fragment's R, G, B, and A values with a destination R, G, B, and A values as stored in the fragment's WebGLFramebuffer.
        /// Blending is dependent on the incoming fragment's alpha value of the currently stored pixel.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If modeRGB or modeAlpha are not one of the three possible values.
        /// </summary>
        /// <param name="modeRGB">One of these values: gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT</param>
        /// <param name="modeAlpha">One of these values: gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT</param>
        public virtual void BlendEquationSeparate(int modeRGB, int modeAlpha) { }

        /// <summary>
        /// Sets the blending factors used to combine source and destination pixels.
        /// The blending function is calculated like this: color(RGBA) = ((source color) * sfactor) + ((destination color) * dfactor). Values of colors are between 0 and 1 for each RGB value. Alpha values are between 1 (fully opaque) and 0 (fully transparent).
        /// Possible sfactor and dfactors multipliers are: ZERO, ONE, SRC_COLOR, ONE_MINUS_SRC_COLOR, DST_COLOR, ONE_MINUS_DST_COLOR, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, DST_ALPHA, ONE_MINUS_DST_ALPHA, SRC_ALPHA_SATURATE
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If the sfactor or the dfactor isn't one of the listed values.
        /// </summary>
        /// <param name="sfactor">A multiplier for the source color.</param>
        /// <param name="dfactor">A multiplier for destination color.</param>
        public virtual void BlendFunc(int sfactor, int dfactor) { }

        /// <summary>
        /// Sets the weighting factors that are used by blendEquationSeparate.
        ///
        /// Possible values for multipliers: ZERO, ONE, SRC_COLOR, ONE_MINUS_SRC_COLOR, DST_COLOR, ONE_MINUS_DST_COLOR, SRC_ALPHA, ONE_MINUS_SRC_ALPHA, DST_ALPHA, ONE_MINUS_DST_ALPHA
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If the srcRGB or the srcAlpha isn't one of the listed values.
        /// </summary>
        /// <param name="srcRGB">A multiplier for the source color.</param>
        /// <param name="dstRGB">A multiplier for the destination color.</param>
        /// <param name="srcAlpha">A multiplier for the source alpha.</param>
        /// <param name="dstAlpha">A multiplier for the destination alpha.</param>
        public virtual void BlendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) { }

        /// <summary>
        /// Creates a buffer in memory and initializes it with array data. If no array is provided, the contents of the buffer is initialized to 0.
        /// BufferData deletes any existing data store and sets the state variables gl.BUFFER_SIZE and gl.BUFFER_USAGE to the new values.
        ///
        /// Errors:
        ///     gl.OUT_OF_MEMORY - If WebGL can't create the buffer to the requested size.
        /// </summary>
        /// <param name="target">Set to gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER.</param>
        /// <param name="size">The size of the buffer to initialize</param>
        /// <param name="usage">One of the following values:
        ///     gl.STATIC_DRAW The data store contents are modified once, and used many times as the source for WebGL drawing commands.
        ///     gl.DYNAMIC_DRAW The data store contents are repeatedly respecified, and used many times as the source for WebGL drawing commands.
        ///     gl.STREAM_DRAW The data store contents are specified once, and used occasionally as the source of a WebGL drawing command.
        ///
        ///     Usage is provided only as a performance hint. The usage value doesn't restrict the way the data store is used.</param>
        public virtual void BufferData(int target, int size, int usage) { }

        /// <summary>
        /// Creates a buffer in memory and initializes it with array data. If no array is provided, the contents of the buffer is initialized to 0.
        /// BufferData deletes any existing data store and sets the state variables gl.BUFFER_SIZE and gl.BUFFER_USAGE to the new values.
        ///
        /// Errors:
        ///     gl.OUT_OF_MEMORY - If WebGL can't create the buffer to the requested size.
        /// </summary>
        /// <param name="target">Set to gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER.</param>
        /// <param name="data">An array of data points</param>
        /// <param name="usage">One of the following values:
        ///     gl.STATIC_DRAW The data store contents are modified once, and used many times as the source for WebGL drawing commands.
        ///     gl.DYNAMIC_DRAW The data store contents are repeatedly respecified, and used many times as the source for WebGL drawing commands.
        ///     gl.STREAM_DRAW The data store contents are specified once, and used occasionally as the source of a WebGL drawing command.
        ///
        ///     Usage is provided only as a performance hint. The usage value doesn't restrict the way the data store is used.</param>
        public virtual void BufferData(int target, ArrayBuffer data, int usage) { }

        /// <summary>
        /// Creates a buffer in memory and initializes it with array data. If no array is provided, the contents of the buffer is initialized to 0.
        /// BufferData deletes any existing data store and sets the state variables gl.BUFFER_SIZE and gl.BUFFER_USAGE to the new values.
        ///
        /// Errors:
        ///     gl.OUT_OF_MEMORY - If WebGL can't create the buffer to the requested size.
        /// </summary>
        /// <param name="target">Set to gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER.</param>
        /// <param name="data">An array of data points</param>
        /// <param name="usage">One of the following values:
        ///     gl.STATIC_DRAW The data store contents are modified once, and used many times as the source for WebGL drawing commands.
        ///     gl.DYNAMIC_DRAW The data store contents are repeatedly respecified, and used many times as the source for WebGL drawing commands.
        ///     gl.STREAM_DRAW The data store contents are specified once, and used occasionally as the source of a WebGL drawing command.
        ///
        ///     Usage is provided only as a performance hint. The usage value doesn't restrict the way the data store is used.</param>
        public virtual void BufferData(int target, ArrayBufferView data, int usage) { }

        /// <summary>
        /// Used to modify or update some or all of a data store for a bound buffer object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If the new data writes past the end of the buffer.
        ///     gl_INVALID_ENUM            If the target is not GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.
        ///     glINVALID_OPERATION        No buffer is bound to target.
        /// </summary>
        /// <param name="target">The bind target of the buffer to update. Set to ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.</param>
        /// <param name="offset">The offset in bytes where data replacement begins. Must be greater than or equal to 0. </param>
        /// <param name="data">The new data to be copied into the buffer.</param>
        public virtual void BufferSubData(int target, int offset, ArrayBufferView data) { }

        /// <summary>
        /// Returns whether the currently bound WebGLFramebuffer is complete. If not complete, returns the reason why.
        ///
        /// One of the following:
        ///     gl.FRAMEBUFFER_COMPLETE                       The frame buffer is ready to display.
        ///     gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT          The attachment types are mismatched.
        ///     gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT  There is no attachment.
        ///     gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS          The height and width of the attachments are not the same.
        ///     gl.FRAMEBUFFER_UNSUPPORTED                    The attachments aren't supported.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM    - If the target isn't gl.FRAMEBUFFER.
        /// </summary>
        /// <param name="target">The following constant - gl.FRAMEBUFFER</param>
        /// <returns>The current status of WebGLFramebuffer</returns>
        public int CheckFramebufferStatus(int target)
        {
            return 0;
        }

        /// <summary>
        /// Sets all pixels in a specific buffer to the same value.
        ///
        /// The mask parameter contains one or both (OR'd together) of the following values:
        ///     gl.DEPTH_BUFFER_BIT        Clears the depth buffer
        ///     gl.STENCIL_BUFFER_BIT    Clears the stencil buffer
        ///     gl.COLOR_BUFFER_BIT        Clears the color buffer
        ///
        /// The clear method sets the buffer to values preselected by clearColor, clearDepth, or clearStencil. If a buffer doesn't exist, this method has no effect.
        /// The clear function can be used to clear the stencil buffer either by itself or in conjunction with other buffers (such as the color or depth buffers).
        /// You can set a stencil write mask prior to clearing the stencil buffer, and the stencil write mask will be respected during the clear operation. This also applies to when the stencil test is disabled.
        ///
        /// Examples:
        ///     gl.clear(gl.DEPTH_BUFFER_BIT);
        ///     gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        ///
        /// Errors:
        ///     gl.INVALID_VALUE                    If any bit other than the ones listed are defined in mask.
        ///     gl.INVALID_FRAMEBUFFER_OPERATION     framebuffer or renderbuffer is in valid.
        /// </summary>
        /// <param name="mask">Contains one or both (OR'd together) of the buffer bits.</param>
        public virtual void Clear(int mask) { }

        /// <summary>
        /// Specifies color values to use by the clear method to clear the color buffer.
        /// The parameters must be in the range of 0 - 1. The default value is 0.
        /// </summary>
        /// <param name="red">The red component. </param>
        /// <param name="green">The green component. </param>
        /// <param name="blue">The blue component. </param>
        /// <param name="alpha">The alpha component. </param>
        public virtual void ClearColor(double red, double green, double blue, double alpha) { }

        /// <summary>
        /// Clears the depth buffer to a specific value.
        /// </summary>
        /// <param name="depth">Value in the range of 0 to 1 to clear the depth buffer to.</param>
        public virtual void ClearDepth(double depth) { }

        /// <summary>
        /// Specifies the clear value to be used by the clear method to clear the stencil buffer.
        /// The s parameter is masked with 2m - 1, where m is the number of bits in the stencil buffer.
        /// </summary>
        /// <param name="s">A value in the range of 0 to 1 to clear the stencil buffer to. Default value is 0.</param>
        public virtual void ClearStencil(double s) { }

        /// <summary>
        /// Lets you set whether individual colors can be written when drawing or rendering to a framebuffer.
        ///
        /// The default value of parameters is true, all colors can be written to the framebuffer.
        /// false on any parameter disables that color from being written.
        /// </summary>
        /// <param name="red">The red component</param>
        /// <param name="green">The green component</param>
        /// <param name="blue">The blue component</param>
        /// <param name="alpha">The alpha component</param>
        public virtual void ColorMask(bool red, bool green, bool blue, bool alpha) { }

        /// <summary>
        /// Compiles the GLSL shader source into binary data used by the WebGLProgram object.
        ///
        /// When compiling shader source code, call getShaderParameter to get the status. getShaderParameter returns true if the source compiled successfully, or false if compilation failed. On failure, call getShaderInfoLog for the shader compiler's log. Errors are contained in the log.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        The shader isn't a WebGLShader object.
        ///                             The shader is not generated by WebGL.
        ///
        ///     gl.INVALID_OPERATION    The shader compiler isn't supported.
        /// </summary>
        /// <param name="shader">An object that represents source code strings. </param>
        public virtual void CompileShader(WebGLShader shader) { }

        /// <summary>
        /// Specifies a two-dimensional texture image or cube Map image from compressed image data. You must call getExtension("WEBGL_compressed_texture_s3tc") to enable compressed textures before calling this method.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If internalFormat does not equal one of the specified values.
        ///     gl.INVALID_OPERATION    If width or height are not a multiple of 4.
        ///     gl.INVALID_ENUM         If target isn't one of the specified values.
        ///     gl.INVALID_ENUM            If internalFormat isn't a supported format.
        ///     gl.INVALID_VALUE        If width or width is less than 0 or greater than gl.MAX_TEXTURE_SIZE.
        ///     gl.INVALID_VALUE        If border is not 0.
        /// </summary>
        /// <param name="target">The target texture. One of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail. Level 0 equals the base image level.</param>
        /// <param name="internalFormat">The image format of the compressed image stored in memory. Use one of the following:
        ///     COMPRESSED_RGB_S3TC_DXT1_EXT    The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 8
        ///     COMPRESSED_RGBA_S3TC_DXT1_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 8
        ///     COMPRESSED_RGBA_S3TC_DXT3_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 16
        ///     COMPRESSED_RGBA_S3TC_DXT5_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 16
        /// </param>
        /// <param name="width">The width of the texture image. A 2D texture image needs to be at least 64 texels wide, and cube-mapped texture images should be 16 texels wide. </param>
        /// <param name="height">The height of the texture image. A 2D texture image needs to be at least 64 texels high, and cube-mapped texture images should be 16 texels high. </param>
        /// <param name="border">Width of border.</param>
        /// <param name="data">Object that contains the image data. </param>
        public virtual void CompressedTexImage2D(int target, int level, int internalFormat, int width, int height, int border, ArrayBufferView data) { }

        /// <summary>
        /// Specifies a two-dimensional texture or cube Map sub-image from compressed image data. You must call getExtension("WEBGL_compressed_texture_s3tc") to enable compressed textures before calling this method.
        /// </summary>
        /// <param name="target">The target texture. One of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail. Level 0 equals the base image level. </param>
        /// <param name="xOffset">The horizontal offset of the image in the texture array.</param>
        /// <param name="yOffset">The vertical offset of the image in the texture array.</param>
        /// <param name="width">The width of the subimage texture.</param>
        /// <param name="height">The height of the subimage texture.</param>
        /// <param name="format">The format or extension of the compressed image. This must be the same format specified previously by compressedTexImage2D. Possible values:
        ///     COMPRESSED_RGB_S3TC_DXT1_EXT    The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 8
        ///     COMPRESSED_RGBA_S3TC_DXT1_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 8
        ///     COMPRESSED_RGBA_S3TC_DXT3_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 16
        ///     COMPRESSED_RGBA_S3TC_DXT5_EXT   The byteLength of data (ArrayBufferView) in pixels that's passed must be match the equation floor((width + 3) / 4) * floor((height + 3) / 4) * 16
        /// </param>
        public virtual void CompressedTexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format) { }

        /// <summary>
        /// Copies a rectangle of pixels from the current WebGLFramebuffer into a texture image.
        /// CopyTexImage2D doesn't support floating point texture sources or destinations.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        Value of target is not one of the specified constants.
        ///
        ///     gl.INVALID_VALUE    The value of level is &lt; 0.
        ///                         If xoffset is &lt; 0.
        ///                         If yoffset is &lt; 0.
        ///                         If xoffset + width is greater than the width of the image being modified.
        ///                         If yoffset + height is greater than the height of the image being modified.
        ///                         If width or if height is &lt; 0.
        ///
        ///     gl.INVALID_OPERATION    No WebGLTexture is bound.
        ///
        ///     gl.INVALID_FRAMEBUFFER_OPERATION        The currently bound WebGLFramebuffer is not framebuffer complete
        ///                                             checkFramebufferStatus does not return gl.FRAMEBUFFER_COMPLETE
        ///                                             The currently bound WebGLRenderbuffer is invalid.
        /// </summary>
        /// <param name="target">The target texture. One of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail. Level 0 equals the base image level. Additional levels (n) equal the nth mipmap reduction image. See generateMipmap to create mipmaps.</param>
        /// <param name="format">Specifies the internal format of the texture.
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="x">Horizontal coordinate of the lower left corner of the pixels to copy.</param>
        /// <param name="y">Vertical coordinate of the lower left corner of the pixels to copy.</param>
        /// <param name="width">The width of the rectangle or box you want to copy from. A 2D texture image needs to be at least 64 texels wide, and cube-mapped texture images should be 16 texels wide. </param>
        /// <param name="height">The height of the rectangle or box you want to copy from. A 2D texture image needs to be at least 64 texels high, and cube-mapped texture images should be 16 texels high. </param>
        /// <param name="border">Width of border. </param>
        public virtual void CopyTexImage2D(int target, int level, int format, int x, int y, int width, int height, int border) { }

        /// <summary>
        /// Replaces a portion of an existing 2D texture image with data from the current framebuffer.
        /// CopyTexImage2D doesn't support floating point texture sources or destinations.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        Value of target is not one of the specified constants.
        ///
        ///     gl.INVALID_VALUE    The value of level is &lt; 0.
        ///                         If xoffset is &lt; 0.
        ///                         If yoffset is &lt; 0.
        ///                         If xoffset + width is greater than the width of the image being modified.
        ///                         If yoffset + height is greater than the height of the image being modified.
        ///                         If width or if height is &lt; 0.
        ///
        ///     gl.INVALID_OPERATION    No WebGLTexture is bound.
        ///
        ///     gl.INVALID_FRAMEBUFFER_OPERATION    The currently bound WebGLFramebuffer is not framebuffer complete
        ///                                         checkFramebufferStatus does not return gl.FRAMEBUFFER_COMPLETE
        /// </summary>
        /// <param name="target">The target texture. One of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail. Level 0 equals the base image level. Additional levels (n) equal the nth mipmap reduction image. See generateMipmap to create mipmaps.</param>
        /// <param name="xOffset">The horizontal offset of the image in the texture array.</param>
        /// <param name="yOffset">The vertical offset of the image in the texture array.</param>
        /// <param name="x">Horizontal coordinate of the lower left corner of the pixels to copy.</param>
        /// <param name="y">Vertical coordinate of the lower left corner of the pixels to copy.</param>
        /// <param name="width">The width of the texture subimage.</param>
        /// <param name="height"></param>
        public virtual void CopyTexSubImage2D(int target, int level, int xOffset, int yOffset, int x, int y, int width, int height) { }

        /// <summary>
        /// Creates and initializes a WebGLBuffer.
        /// </summary>
        /// <returns>The buffer object.</returns>
        public WebGLBuffer CreateBuffer()
        {
            return null;
        }

        /// <summary>
        /// Returns a WebGLFramebuffer object.
        /// </summary>
        /// <returns>The framebuffer object.</returns>
        public WebGLFramebuffer CreateFramebuffer()
        {
            return null;
        }

        /// <summary>
        /// Creates an empty WebGLProgram object to which vector and fragment WebGLShader objects can be bound.
        /// Return a 0 if an error occurs creating a program object.
        /// </summary>
        /// <returns>A program object or 0 if error</returns>
        public Any<int, WebGLProgram> CreateProgram()
        {
            return null;
        }

        /// <summary>
        /// Creates and returns a WebGLRenderbuffer object.
        /// </summary>
        /// <returns>The render buffer object.</returns>
        public WebGLRenderbuffer CreateRenderbuffer()
        {
            return null;
        }

        /// <summary>
        /// Returns an empty vertex or fragment shader object based on the type specified.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        The shader type is not an accepted value.
        /// </summary>
        /// <param name="type">Either gl.FRAGMENT_SHADER or gl.VERTEX_SHADER constants. </param>
        /// <returns>Shader object of type fragment or vertex shader. </returns>
        public WebGLShader CreateShader(int type)
        {
            return null;
        }

        /// <summary>
        /// Used to generate a WebGLTexture object to which images can be bound.
        /// </summary>
        /// <returns>Texture object.</returns>
        public WebGLTexture CreateTexture()
        {
            return null;
        }

        /// <summary>
        /// Sets whether or not front, back, or both facing facets are able to be culled.
        /// </summary>
        /// <param name="mode">Sets which facets are candidates for culling.
        ///     gl.FRONT
        ///     gl.BACK
        ///     gl.FRONT_AND_BACK
        /// </param>
        public virtual void CullFace(int mode) { }

        /// <summary>
        /// Delete a specific buffer.
        /// If a buffer has already been deleted, this method has no effect.
        /// </summary>
        /// <param name="buffer">The buffer to delete</param>
        public virtual void DeleteBuffer(WebGLBuffer buffer) { }

        /// <summary>
        /// Deletes a specific WebGLFramebuffer object. If you delete the currently bound framebuffer, the default framebuffer will be bound. Deleting a framebuffer detaches all of its attachments.
        /// If a buffer has already been deleted, this method has no effect.
        /// </summary>
        /// <param name="framebuffer">Framebuffer object to delete.</param>
        public virtual void DeleteFramebuffer(WebGLFramebuffer framebuffer) { }

        /// <summary>
        /// Flags a specific WebGLProgram object for deletion if currently active. It will be deleted when it is no longer being used. Any shader objects associated with the program will be detached. They will be deleted if they were already flagged for deletion.
        /// </summary>
        /// <param name="program">The program to be deleted.</param>
        public virtual void DeleteProgram(WebGLProgram program) { }

        /// <summary>
        /// Deletes the specified renderbuffer object. If the renderbuffer is currently bound, it will become unbound. If the renderbuffer is attached to the currently bound framebuffer, it is detached.
        /// If renderbuffer has previously been deleted, this method has no effect.
        /// </summary>
        /// <param name="renderbuffer">The renderbuffer object to delete.</param>
        public virtual void DeleteRenderbuffer(WebGLRenderbuffer renderbuffer) { }

        /// <summary>
        /// Deletes a specific shader object.
        /// If shader is attached to a program object, it's flagged for deletion until it's no longer attached to the object. A shader needs to be detached with detachShader before it can be deleted.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    If the shader isn't generated by WebGL.
        /// </summary>
        /// <param name="shader">The shader to delete</param>
        public virtual void DeleteShader(WebGLShader shader) { }

        /// <summary>
        /// Deletes a specific texture object.
        /// If texture is currently bound is deleted, the binding reverts to a default 0 value texture.
        /// </summary>
        /// <param name="texture">The texture to delete</param>
        public virtual void DeleteTexture(WebGLTexture texture) { }

        /// <summary>
        /// Sets a function to use to compare incoming pixel depth to the current depth buffer value.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If func is not from the listed values.
        /// </summary>
        /// <param name="func">Sets conditions for pixels to be drawn. Use one of the following comparison values:
        ///     gl.NEVER        Incoming value never passes.
        ///     gl.LESS         Pass if the incoming value is less than the depth buffer value.
        ///     gl.EQUAL        Pass if the incoming value is equal to the depth buffer value.
        ///     gl.LEQUAL       Pass if the incoming value is less than or equal to the depth buffer value.
        ///     gl.GREATER      Pass if the incoming value is greater than the depth buffer value.
        ///     gl.NOTEQUAL     Pass if the incoming value isn't equal to the depth buffer value.
        ///     gl.GEQUAL       Pass if the incoming value is greater than or equal to the depth buffer value.
        ///     gl.ALWAYS       Always pass, regardless of value.
        /// </param>
        public virtual void DepthFunc(int func) { }

        /// <summary>
        /// Sets whether or not you can write to the depth buffer.
        /// </summary>
        /// <param name="flag">true - you can write to the depth buffer.
        /// false - you can't write to the depth buffer.</param>
        public virtual void DepthMask(bool flag) { }

        /// <summary>
        /// Sets the depth range for normalized coordinates to canvas or viewport depth coordinates.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    If the zNear value is greater than zFar.
        /// </summary>
        /// <param name="zNear">Value between 0 - 1, and less than or equal to zFar. Initial value of 0.</param>
        /// <param name="zFar">Value in the range of 0 - 1. Initial value of 1.</param>
        public virtual void DepthRange(double zNear, double zFar) { }

        /// <summary>
        /// Detach a shader object from a program object.
        /// If the shader is flagged for deletion by deleteShader, it's deleted after it's removed.
        /// </summary>
        /// <param name="program">The program object that contains the shader to detach. </param>
        /// <param name="shader">The shader to detach.</param>
        public virtual void DetachShader(WebGLProgram program, WebGLShader shader) { }

        /// <summary>
        /// Turns off specific WebGL capabilities for this context.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If capability is not from the listed values.
        /// </summary>
        /// <param name="capability">One of the following values:
        ///     gl.BLEND                    Don't blend computed fragment color values with color buffer values.
        ///     gl.DEPTH_TEST               Don't update the depth buffer, including when the depth buffer exists and the depth mask is non-zero.
        ///     gl.CULL_FACE                Don't cull polygons. see cullFace.
        ///     gl.POLYGON_OFFSET_FILL      Don't add an offset to the depth values of a polygon's fragments.
        ///     gl.SCISSOR_TEST             Don't discard fragments outside a scissor rectangle.
        /// </param>
        public virtual void Disable(int capability) { }

        /// <summary>
        /// Turns off a vertex attribute array at a specific index position.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    If the index is negative or greater than the gl.MAX_VERTEX_ATTRIBS.
        /// </summary>
        /// <param name="index">Index of the vertex attribute to disable.</param>
        public virtual void DisableVertexAttribArray(int index) { }

        /// <summary>
        /// Render geometric primitives from bound and enabled vertex data.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM                        If mode is not an accepted value.
        ///     gl.INVALID_VALUE                    If count is negative.
        ///     gl.INVALID_FRAMEBUFFER_OPERATION    If the currently bound WebGLFramebuffer is not framebuffer complete or the WebGLRenderbuffer is invalid.
        ///     gl.INVALID_OPERATION                The vertex attribute is enabled but no buffer is bound or if first + count goes past the end of the vertex attribute array.
        /// </summary>
        /// <param name="mode">Specifies the kind of geometric primitives to render from a given set of vertex attributes.
        ///     gl.POINTS           Draws a single dot per vertex. For example, 10 vertices produce 10 dots.
        ///     gl.LINES            Draws a line between a pair of vertices. For example, 10 vertices produce 5 separate lines.
        ///     gl.LINE_STRIP       Draws a line to the next vertex by a straight line. For example, 10 vertices produce 9 lines connected end to end.
        ///     gl.LINE_LOOP        Similar to gl.LINE_STRIP, but connects the last vertex back to the first. For example, 10 vertices produce 10 straight lines.
        ///     gl.TRIANGLES        Draws a triangle for each group of three consecutive vertices. For example, 12 vertices create 4 separate triangles.
        ///     gl.TRIANGLE_STRIP   Creates a strip of triangles where each additional vertex creates an additional triangle once the first three vertices have been drawn. For example, 12 vertices create 10 triangles.
        ///     gl.TRIANGLE_FAN     Similar to gl.TRIANGLE_STRIP, but creates a fan shaped output. For example 12 vertices create 10 triangles.
        /// </param>
        /// <param name="first">The first element to render in the array of vector points.</param>
        /// <param name="count">The number of vector points to render. For example, a triangle would be 3.</param>
        public virtual void DrawArrays(int mode, int first, int count) { }

        /// <summary>
        /// Renders geometric primitives indexed by element array data.
        /// </summary>
        /// <param name="mode">Specifies the kind of primitives to render.
        ///     gl.POINTS           Draws a single dot per vertex. For example, 10 vertices produce 10 dots.
        ///     gl.LINES            Draws a line between a pair of vertices. For example, 10 vertices produce 5 separate lines.
        ///     gl.LINE_STRIP       Draws a line to the next vertex by a straight line. For example, 10 vertices produce 9 lines connected end to end.
        ///     gl.LINE_LOOP        Similar to gl.LINE_STRIP, but connects the last vertex back to the first. For example, 10 vertices produce 10 straight lines.
        ///     gl.TRIANGLES        Draws a triangle for each group of three consecutive vertices. For example, 12 vertices create 4 separate triangles.
        ///     gl.TRIANGLE_STRIP   Creates a strip of triangles where each additional vertex creates an additional triangle once the first three vertices have been drawn. For example, 12 vertices create 10 triangles.
        ///     gl.TRIANGLE_FAN     Similar to gl.TRIANGLE_STRIP, but creates a fan shaped output. For example 12 vertices create 10 triangles.
        /// </param>
        /// <param name="count">The number of elements to render.</param>
        /// <param name="type">The type of elements in the element array buffer. Must be a gl.UNSIGNED_SHORT.</param>
        /// <param name="offset">Offset into the element array buffer. Must be a valid multiple of the size of type.</param>
        public virtual void DrawElements(int mode, int count, int type, int offset) { }

        /// <summary>
        /// Turns on specific WebGL capabilities for this context.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If capability is not from the listed values.
        /// </summary>
        /// <param name="capability">One of the following values:
        ///     gl.BLEND                    Don't blend computed fragment color values with color buffer values.
        ///     gl.DEPTH_TEST               Don't update the depth buffer, including when the depth buffer exists and the depth mask is non-zero.
        ///     gl.CULL_FACE                Don't cull polygons. see cullFace.
        ///     gl.POLYGON_OFFSET_FILL      Don't add an offset to the depth values of a polygon's fragments.
        ///     gl.SCISSOR_TEST             Don't discard fragments outside a scissor rectangle.
        /// </param>
        public virtual void Enable(int capability) { }

        /// <summary>
        /// Turns on a vertex attribute at a specific index position in a vertex attribute array.
        /// All client-side capabilities are disabled by default, including all vertex attribute arrays.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    If the index is negative or greater than the gl.MAX_VERTEX_ATTRIBS.
        /// </summary>
        /// <param name="index">Index of the vertex attribute to enable.</param>
        public virtual void EnableVertexAttribArray(int index) { }

        /// <summary>
        /// Attaches a WebGLRenderbuffer object as a logical buffer to the currently bound WebGLFramebuffer object.
        /// </summary>
        /// <param name="target">Always use gl.FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point. One of the following:
        ///     gl.COLOR_ATTACHMENT0
        ///     gl.DEPTH_ATTACHMENT
        ///     gl.STENCIL_ATTACHEMENT
        ///     gl.DEPTH_STENCIL_ATTACHEMENT
        /// </param>
        /// <param name="renderbufferTarget">Always use gl.RENDERBUFFER. </param>
        /// <param name="renderbuffer">The WebGLRenderbuffer object to attach.</param>
        public virtual void FramebufferRenderbuffer(int target, int attachment, int renderbufferTarget, WebGLRenderbuffer renderbuffer) { }

        /// <summary>
        /// Attaches a texture to a WebGLFramebuffer object.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If textarget isn't from the listed values, and texture isn't 0.
        ///                         If target isn't gl.FRAMEBUFFER.
        ///                         If attachment isn't from the listed values.
        ///
        ///     gl.INVALID_OPERATION    If the default framebuffer object name 0 is bound.
        ///                             If texture isn't 0 or the name of an existing texture object
        /// </summary>
        /// <param name="target">Always use gl.FRAMEBUFFER.</param>
        /// <param name="attachment">Specifies the attachment point. One of the following:
        ///     gl.COLOR_ATTACHMENT0
        ///     gl.DEPTH_ATTACHMENT
        ///     gl.STENCIL_ATTACHEMENT
        ///     gl.DEPTH_STENCIL_ATTACHEMENT
        /// </param>
        /// <param name="texTarget">The texture target:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube.
        /// </param>
        /// <param name="texture">WebGLTexture object with image to attach.</param>
        /// <param name="level">The mipmap level of the texture image to attach. Always set to 0.</param>
        public virtual void FramebufferTexture2D(int target, int attachment, int texTarget, WebGLTexture texture, int level) { }

        /// <summary>
        /// Sets whether or not polygons are considered front-facing based on their winding direction.
        /// A polygon has a clockwise winding if an imaginary object following a path moves in a clockwise direction from the first vertex, second vertex, and so forth, to the last vertex, and then back to the first vertex. It's counterclockwise winding if it moves in the opposite direction.
        /// To turn rendering of back-facing polygons on or off, call enable or disable using CULL_FACE as the argument.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        Mode is not CW or CCW.
        /// </summary>
        /// <param name="mode">Sets orientation of front-facing polygons.
        ///     gl.CCW      Initial value. Counterclockwise winding.
        ///     gl.CW       Clockwise winding.
        /// </param>
        public virtual void FrontFace(int mode) { }

        /// <summary>
        /// Creates a set of textures for a WebGLTexture object with image dimensions from the original size of the image down to a 1x1 image.
        /// A mipmap is used to simulate distance with objects. A high-resolution mipmap image is used for objects that are close to the user. Lower-resolution images are used as the object appears farther away. Using mipmaps improves the quality of rendered textures at the expense of using more memory.
        /// The internal format of a mipmap array is the same as the zero level texture image. Each level is half the resolution of the previous level, until a 1x1 dimension texture image is created.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            target isn't specified as gl.TEXTURE_2D or gl.TEXTURE_CUBE_MAP.
        ///     gl.INVALID_OPERATION    If the width or height of the zero level (original texture) array is not a power of two.
        /// </summary>
        /// <param name="target">The texture target of the active texture unit.
        ///     gl.TEXTURE_2D
        ///     gl.TEXTURE_CUBE_MAP
        /// </param>
        public virtual void GenerateMipmap(int target) { }

        /// <summary>
        /// Returns an WebGLActiveInfo object containing the size, type, and name of a vertex attribute at a specific index position in a program object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        The value of program is not generated by WebGL.
        ///                             The value of index is greater than or equal to the number of active attribute variables in program.
        ///
        ///     gl.INVALID_OPERATION    The value program is not a valid program object.
        /// </summary>
        /// <param name="program">The program object containing the vertex attribute of interest.</param>
        /// <param name="index">The index of the attribute. Index is zero based. Passing 0 selects the first attribute, while gl.ACTIVE_ATTRIBUTES - 1 specifies the last attribute.</param>
        /// <returns>A WebGLActiveInfo object.</returns>
        public virtual WebGLActiveInfo GetActiveAttrib(WebGLProgram program, int index)
        {
            return null;
        }

        /// <summary>
        /// Returns an WebGLActiveInfo object containing the size, type, and name of a uniform attribute at a specific index position in a program object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        The value of program is not generated by WebGL.
        ///                             The value of index is greater than or equal to the number of active uniforms in program.
        ///
        ///     gl.INVALID_OPERATION    The program is not a valid program object.
        /// </summary>
        /// <param name="program">The program object containing the uniform attribute of interest.</param>
        /// <param name="index">The index of the uniform. The index is zero based. Passing 0 selects the first uniform, while ACTIVE_ATTRIBUTES - 1 specifies the last uniform.</param>
        /// <returns>A WebGLActiveInfo object.</returns>
        public virtual WebGLActiveInfo GetActiveUniform(WebGLProgram program, int index)
        {
            return null;
        }

        /// <summary>
        /// Returns a list of WebGLShaders bound to a WebGLProgram.
        /// </summary>
        /// <param name="program">The WebGLProgram object from which to get list of WebGLShaders</param>
        /// <returns>Array of the WebGLShaders that are bound to program.</returns>
        public virtual WebGLShader[] FetAttachedShaders(WebGLProgram program)
        {
            return null;
        }

        /// <summary>
        /// Returns an index to the location in a program of a named attribute variable.
        /// If name is a matrix variable, index points to the first column of the matrix.
        /// </summary>
        /// <param name="program">The program object.</param>
        /// <param name="name">The name of the attribute variable.</param>
        /// <returns>The location of the attribute variable name if found. Returns a -1 if not.</returns>
        public virtual int GetAttribLocation(WebGLProgram program, string name)
        {
            return 0;
        }

        /// <summary>
        /// Returns the type of a parameter for a given buffer.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            target or value are not acceptable values
        ///     gl.INVALID_OPERATION    The reserved buffer object name 0 is bound to target.
        /// </summary>
        /// <param name="target">One of the following: gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER</param>
        /// <param name="pName">One of the following: gl.BUFFER_SIZE or gl.BUFFER_USAGE</param>
        /// <returns>The type of parameter</returns>
        public virtual string GetBufferParameter(int target, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns an object that describes the attributes set on a context when it was created.
        /// </summary>
        /// <returns>An object that contains the attributes. See WebGLContextAttributes for more info.</returns>
        public virtual WebGLContextAttributes GetContextAttributes()
        {
            return null;
        }

        /// <summary>
        /// Returns a value for the WebGL error flag and clears the flag.
        /// No additional errors are recorded until this method is called. When you call getError, it returns the error code and resets the error flag.
        ///
        /// Possible errors:
        ///
        ///     OUT_OF_MEMORY                       The command requires more memory than is available. After this error is reported, the state of the WebGL context is undefined except for error flags.
        ///     INVALID_ENUM                        An unacceptable value for an enumerated argument was specified.
        ///     INVALID_OPERATION                   The specified operation isn't allowed for the current state. The command is ignored.
        ///     INVALID_FRAMEBUFFER_OPERATION       The command is attempting to read or render from a framebuffer that is not framebuffer complete. A call to checkFramebufferStatus doesn't return gl.FRAMEBUFFER_COMPLETE.
        ///     INVALID_VALUE                       A number that was passed is out of range. The unacceptable value is ignored.
        ///     CONTEXT_LOST_WEBGL                  If WebGL context is lost, this error is returned on the first call to getError. Subsequent calls return NO_ERROR until context is restored.
        ///     NO_ERROR                            No error has been recorded. This can occur if getError has been called previously, and continues until the error has been corrected.
        /// </summary>
        /// <returns>Error code.</returns>
        public virtual int GetError()
        {
            return 0;
        }

        /// <summary>
        /// Enables a passed extension, otherwise returns null.
        /// Returns null if an extension isn't supported.
        /// </summary>
        /// <param name="name">A case-insensitive name of the extension.
        ///     OES_texture_float                           When enabled, allows 128bits-per-pixel texture components rather than 32bit to be used with texImage2D and texSubImage2D. Call getExtension("gl.OES_texture_float"). When using floating-point textures, linear filtering isn't supported, only nearest filtering.
        ///     EXT_texture_filter_anisotropic 0x84FE       Call getExtension("gl.EXT_texture_filter_anisotropic") to enable. When enabled provides anisotropic filtering functionality. Anisotropic filtering enhances image quality for textures at oblique viewing angles. For more info, see Anisotropic filtering.
        /// </param>
        /// <returns>Object that contains any existing constants or functions defined in the extension, or null.</returns>
        public virtual object GetExtension(string name)
        {
            return null;
        }

        /// <summary>
        /// Gets a parameter value for a given target and attachment.
        /// </summary>
        /// <param name="target">Defines what the target is. Must be the constant gl.FRAMEBUFFER.</param>
        /// <param name="attachment">One of the following:
        ///     gl.COLOR_ATTACHMENT0
        ///     gl.DEPTH_ATTACHMENT
        ///     gl.STENCIL_ATTACHMENT
        ///     gl.DEPTH_STENCIL_ATTACHMENT
        /// </param>
        /// <param name="pName">The name of the attachment parameter to get.
        ///     gl.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
        ///     gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
        ///     gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
        ///     gl.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
        /// </param>
        /// <returns>The parameter value</returns>
        public virtual object GetFramebufferAttachmentParameter(int target, int attachment, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns the natural type value for a constant parameter.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If pname isn't an accepted value.
        /// </summary>
        /// <param name="pName">Parameter to look up.</param>
        /// <returns>The parameter value</returns>
        public virtual object GetParameter(object pName)
        {
            return null;
        }

        /// <summary>
        /// Returns information about the last error that occurred during the failed linking or validation of a WebGL program object.
        /// This method returns the last error that occurred during program linking or validation. WebGL reports one error at a time, and won't return another error until the reported error has been corrected.
        ///
        /// Errors:
        ///
        ///     gl.INVALID_VALUE        If program isn't a WebGL object.
        ///     gl.INVALID_OPERATION    If program isn't a program object.
        /// </summary>
        /// <param name="program">The program object to get the information for. </param>
        /// <returns>The information (error, warning, or informational messages), or an empty string if none. Returns null if an error occurs.</returns>
        public virtual string GetProgramInfoLog(WebGLProgram program)
        {
            return null;
        }

        /// <summary>
        /// Returns the value of the program parameter that corresponds to a supplied pname for a given program, or null if an error occurs.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            If pname isn't in the table above.
        ///     gl.INVALID_OPERATION    If program isn't a program object.
        /// </summary>
        /// <param name="program">The program object to query for pname.</param>
        /// <param name="pName">The parameter constant.
        ///     Parameter              Returned type
        ///
        ///     gl.DELETE_STATUS        Boolean
        ///     gl.LINK_STATUS            Boolean
        ///     gl.VALIDATE_STATUS        Boolean
        ///     gl.ATTACHED_SHADERS        Number
        ///     gl.ACTIVE_ATTRIBUTES    Number
        ///     gl.ACTIVE_UNIFORMS        Number
        /// </param>
        /// <returns>The value for a parameter associated with pname, or null if an error occurs.</returns>
        public virtual Any<bool, int, object> GetProgramParameter(WebGLProgram program, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns a renderbuffer parameter from the currently bound WebGLRenderbuffer object.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            If target isn't gl.RENDERBUFFER.
        ///                             If pname isn't one of the listed constants.
        ///
        ///     gl.INVALID_OPERATION    If no renderbuffer is bound.
        /// </summary>
        /// <param name="target">Constant, must be gl.RENDERBUFFER.</param>
        /// <param name="pName">Values for the image in the currently bound WebGLRenderbuffer object.
        ///     Parameter                           Description                                                 Default
        ///
        ///     gl.RENDERBUFFER_WIDTH                The width (in pixels).                                         0
        ///     gl.RENDERBUFFER_HEIGHT                The height (in pixels).                                     0
        ///     gl.RENDERBUFFER_INTERNAL_FORMAT        The internal format for the image.                             RGBA4
        ///     gl.RENDERBUFFER_GREEN_SIZE            The resolution size (in bits) for the green component.        0
        ///     gl.RENDERBUFFER_BLUE_SIZE            The resolution size (in bits) for the blue component.        0
        ///     gl.RENDERBUFFER_RED_SIZE            The resolution size (in bits) for the red component.        0
        ///     gl.RENDERBUFFER_ALPHA_SIZE            The resolution size (in bits) for the alpha component.        0
        ///     gl.RENDERBUFFER_DEPTH_SIZE            The resolution size (in bits) for the depth component.        0
        ///     gl.RENDERBUFFER_STENCIL_SIZE        The resolution size (in bits) for the stencil component.    0
        /// </param>
        /// <returns>Returns the value of the parameter specified by pname, or null if an error.</returns>
        public virtual int? GetRenderbufferParameter(int target, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns errors which occur when compiling a shader.
        /// Shader compilation errors are written to the shader's info log.
        /// To get compile status, call gl.getShaderParameter(myShader,gl.COMPILE_STATUS) to check for a failed compile. On a failed compile, call gl.getShaderInfoLog(myShader) to get the error information. This method only returns the info log, but doesn't clear the log like getError does.
        /// </summary>
        /// <param name="shader">The shader object.</param>
        /// <returns>The information log.</returns>
        public virtual string GetShaderInfoLog(WebGLShader shader)
        {
            return null;
        }

        /// <summary>
        /// Returns the value of the parameter associated with pname for a shader object.
        /// </summary>
        /// <param name="shader">The shader object to query. </param>
        /// <param name="pName">The parameter to look up.
        ///     Parameter               Returned type
        ///
        ///     gl.SHADER_TYPE            Number
        ///     gl.DELETE_STATUS        Boolean
        ///     gl.COMPILE_STATUS        Boolean
        /// </param>
        /// <returns>Value of pname.</returns>
        public virtual Any<int, bool, object> GetShaderParameter(WebGLShader shader, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns the precision and range of the supplied numeric format for a given shader type.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            If either shaderType or precisionType aren't accepted values.
        ///     gl.INVALID_OPERATION    If the shader compiler isn't supported.
        /// </summary>
        /// <param name="shaderType">Type of shader. One of the following: gl.VERTEX_SHADER,  gl.FRAGMENT_SHADER</param>
        /// <param name="precisionType">The numeric format to query for range and precision. One of the following:
        ///     gl.LOW_FLOAT
        ///     gl.MEDIUM_FLOAT
        ///     gl.HIGH_FLOAT
        ///     gl.LOW_INT
        ///     gl.MEDIUM_INT
        ///     gl.HIGH_INT
        /// </param>
        /// <returns>Precision and range of numeric format.</returns>
        public virtual WebGLShaderPrecisionFormat GetShaderPrecisionFormat(int shaderType, int precisionType)
        {
            return null;
        }

        /// <summary>
        /// Returns source code string associated with a shader object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If shader is not valid.
        ///     gl.INVALID_OPERATION    If shader is not a shader object.
        /// </summary>
        /// <param name="shader">The shader object to query.</param>
        /// <returns>The shader source code string. Returns null if an error occurred. </returns>
        public virtual string GetShaderSource(WebGLShader shader)
        {
            return null;
        }

        /// <summary>
        /// Returns an array of supported extension strings.
        /// </summary>
        /// <returns>Array of supported extension strings, or an empty array object if there are none.</returns>
        public virtual string[] GetSupportedExtensions()
        {
            return null;
        }

        /// <summary>
        /// Returns the value for a parameter on an active texture unit.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        pname is not one of the listed constants.
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be gl.TEXTURE_2D and gl.TEXTURE_CUBE_MAP.</param>
        /// <param name="pName">Parameter:
        ///     gl.TEXTURE_MAG_FILTER
        ///     gl.TEXTURE_MIN_FILTER
        ///     gl.TEXTURE_WRAP_S
        ///     gl.TEXTURE_WRAP_T
        /// </param>
        /// <returns>The texture parameter type. See table below. Returns null if a WebGL error occurs.</returns>
        public virtual int? GetTexParameter(int target, int pName)
        {
            return null;
        }

        /// <summary>
        /// Gets the uniform value for a specific location in a program.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    If program is not generated by WebGL.
        ///
        ///     gl.INVALID_OPERATION        If location isn't a valid uniform variable location for program
        ///                                 If program is not a program object.
        ///                                 if program isn't successfully linked.
        /// </summary>
        /// <param name="program">The program to query.</param>
        /// <param name="location">The location of the uniform variable.</param>
        /// <returns>The uniform value or null if a WebGL error is generated.</returns>
        public virtual object GetUniform(WebGLProgram program, WebGLUniformLocation location)
        {
            return null;
        }

        /// <summary>
        /// Returns a WebGLUniformLocation object for the location of a uniform variable within a WebGLProgram object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If program is not generated by WebGL.
        ///
        ///     gl.INVALID_OPERATION    If program is not a program object.
        ///                             if program isn't successfully linked.
        /// </summary>
        /// <param name="program">The program object to query.</param>
        /// <param name="name">A string containing the name of the uniform variable. </param>
        /// <returns>The WebGLUniformLocation for the name. Returns null if a WebGL error occurs or if name starts with a reserved WebGL prefix.</returns>
        public virtual WebGLUniformLocation GetUniformLocation(WebGLProgram program, string name)
        {
            return null;
        }

        /// <summary>
        /// Returns data for a particular characteristic of a vertex attribute at an index in a vertex attribute array.
        ///
        /// The following table shows the return value for a given pName.
        ///     Parameter                                   Returned type       Description
        ///
        ///     gl.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING        WebGLBuffer            The name of the currently bound buffer object. Returns 0 if no buffer is bound.
        ///     gl.VERTEX_ATTRIB_ARRAY_ENABLED                Boolean                Returns true if the vertex attribute at index is enabled, otherwise false. Initial value is false.
        ///     gl.VERTEX_ATTRIB_ARRAY_SIZE                    Number                Returns the size (1,2,3,or 4) for an element of the vertex array. Initial value is 4.
        ///     gl.VERTEX_ATTRIB_ARRAY_STRIDE                Number                Returns the number of bytes between successive elements in the array. The value 0 means the elements are sequential in memory. Initial value is 0.
        ///     gl.VERTEX_ATTRIB_ARRAY_TYPE                    GLenum                Returns a constant representing the array type. Possible values are: gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.  The initial value is gl.FLOAT.
        ///     gl.VERTEX_ATTRIB_ARRAY_NORMALIZED            Boolean                Returns true if fixed-point data types for the vertex attribute array at index are normalized when converted to floating point. Otherwise false is returned. Initial value is false.
        ///     gl.CURRENT_VERTEX_ATTRIB                    Float32Array        Returns four values that currently represent the value of the vertex attribute at index. Initial value is 0,0,0,1.
        ///                                                 (with 4 elements)
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        If pname isn't an accepted value.
        ///     gl.INVALID_VALUE    If index is greater than or equal to gl.MAX_VERTEX_ATTRIBS.
        /// </summary>
        /// <param name="index">The index of the vertex attribute to query.</param>
        /// <param name="pName">The symbolic name for the attribute parameter to look up. See remarks for acceptable values.</param>
        /// <returns>The data specified by pname for the vertex attribute at index. Returns null if an error condition occurs, such as an invalid pname.</returns>
        public virtual object GetVertexAttrib(int index, int pName)
        {
            return null;
        }

        /// <summary>
        /// Returns the address of a specified vertex attribute.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM        pname isn't the constant gl.VERTEX_ATTRIB_ARRAY_POINTER
        ///     gl.INVALID_VALUE    index is greater than or equal to gl.MAX_VERTEX_ATTRIBS
        /// </summary>
        /// <param name="index">The index of the vertex attribute to query. </param>
        /// <param name="pName">Must be gl.VERTEX_ATTRIB_ARRAY_POINTER</param>
        /// <returns>The address of the vertex attribute. Returns a null if an error is generated. Returns 0 if the context lost flag is set.</returns>
        public virtual int GetVertexAttribOffset(int index, int pName)
        {
            return 0;
        }

        /// <summary>
        /// Gets state of WebGLBuffer. Returns true if buffer is valid, false otherwise.
        /// </summary>
        /// <param name="buffer">The buffer to query.</param>
        /// <returns>Returns true if buffer is valid, false otherwise. </returns>
        public virtual bool IsBuffer(WebGLBuffer buffer)
        {
            return false;
        }

        /// <summary>
        /// Returns whether the WebGL context has been lost.
        /// </summary>
        /// <returns>Returns true if context lost flag is set, false otherwise. </returns>
        public virtual bool IsContextLost()
        {
            return false;
        }

        /// <summary>
        /// Returns whether or not a WebGL capability is enabled for this context.
        /// </summary>
        /// <param name="capability">One of the following:
        ///     gl.BLEND                    Don't blend computed fragment color values with color buffer values.
        ///     gl.DEPTH_TEST               Don't update the depth buffer, including when the depth buffer exists and the depth mask is non-zero.
        ///     gl.CULL_FACE                Don't cull polygons. see cullFace.
        ///     gl.POLYGON_OFFSET_FILL      Don't add an offset to the depth values of a polygon's fragments.
        ///     gl.SCISSOR_TEST             Don't discard fragments outside a scissor rectangle.
        /// </param>
        /// <returns>Returns true if supported, otherwise false.
        /// Returns false if the context lost flag is set.
        /// Returns false if the value for capability is invalid.
        /// Returns undefined rather than false when function is called with an unsupported capability value.</returns>
        public virtual bool IsEnabled(int capability)
        {
            return false;
        }

        /// <summary>
        /// Gets state of framebuffer. Returns true if buffer is valid, false otherwise.
        /// </summary>
        /// <param name="framebuffer">The framebuffer to query. </param>
        /// <returns>True if framebuffer is valid, false otherwise. </returns>
        public virtual bool IsFramebuffer(WebGLFramebuffer framebuffer)
        {
            return false;
        }

        /// <summary>
        /// Gets state of WebGL program object. Returns true if program object is valid, false otherwise.
        /// </summary>
        /// <param name="program">The program object to query.</param>
        /// <returns>Returns true if program is valid, false otherwise.</returns>
        public virtual bool IsProgram(WebGLProgram program)
        {
            return false;
        }

        /// <summary>
        /// Gets state of WebGL renderbuffer. Returns true if buffer is valid, false otherwise.
        /// </summary>
        /// <param name="renderbuffer">Renderbuffer to query.</param>
        /// <returns>Returns true if renderbuffer is valid, false otherwise.</returns>
        public virtual bool IsRenderbuffer(WebGLRenderbuffer renderbuffer)
        {
            return false;
        }

        /// <summary>
        /// Gets state of WebGL shader. Returns true if shader is valid, false otherwise.
        /// </summary>
        /// <param name="shader">Shader to query.</param>
        /// <returns>Returns true if shader is valid, false otherwise. </returns>
        public virtual bool IsShader(WebGLShader shader)
        {
            return false;
        }

        /// <summary>
        /// Gets state of WebGL texture. Returns true if texture is valid, false otherwise.
        /// </summary>
        /// <param name="texture">Texture to query.</param>
        /// <returns>Returns true of texture is valid, false otherwise.</returns>
        public virtual bool IsTexture(WebGLTexture texture)
        {
            return false;
        }

        /// <summary>
        /// Sets the width of lines in WebGL.
        /// </summary>
        /// <param name="width">Width of lines.</param>
        public virtual void LineWidth(int width) { }

        /// <summary>
        /// Links an attached vertex shader and an attached fragment shader to a program so it can be used by the graphics processing unit (GPU).
        /// If a link operation fails, any info associated with a previous link operation of program is lost.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE         If program isn't a WebGL object type.
        ///     gl.INVALID_OPERATION    If program isn't a program object.
        /// </summary>
        /// <param name="program">The program object to link.</param>
        public virtual void LinkProgram(WebGLProgram program) { }

        /// <summary>
        /// Sets pixel storage modes for readPixels and unpacking of textures with texImage2D and texSubImage2D .
        /// </summary>
        /// <param name="pName">The symbolic parameter name. One of the following:
        ///     gl.PACK_ALIGNMENT                       Affects packing of pixel data into memory. The initial param value is 4, but it can be set to 1,2,4, or 8.
        ///     gl.UNPACK_ALIGNMENT                     Affects unpacking of pixel data from memory. The initial param value is 4, but can be set to 1,2,4, or 8.
        ///     gl.UNPACK_FLIP_Y_WEBGL                  Flips the source data along its vertical axis when texImage2D or texSubImage2D are called when param is true. The initial value for param is false.
        ///     gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL       Multiplies the alpha channel, if it exists, into the other color channels during the data transfer when texImage2D or texSubImage2D are called when param is true. The initial value for param is false.
        ///     gl.UNPACK_COLORSPACE_CONVERSION_WEBGL   The browser's default colorspace conversion is applied when texImage2D or texSubImage2D are called with an HTMLImageElement texture data source. The initial value for param is BROWSER_DEFAULT_WEBGL. No colorspace conversion is applied when set to NONE.
        /// </param>
        /// <param name="param">Values depend on value of pname.</param>
        public virtual void PixelStorei(int pName, int param) { }

        /// <summary>
        /// Sets pixel storage modes for readPixels and unpacking of textures with texImage2D and texSubImage2D .
        /// </summary>
        /// <param name="pName">The symbolic parameter name. One of the following:
        ///     gl.PACK_ALIGNMENT                       Affects packing of pixel data into memory. The initial param value is 4, but it can be set to 1,2,4, or 8.
        ///     gl.UNPACK_ALIGNMENT                     Affects unpacking of pixel data from memory. The initial param value is 4, but can be set to 1,2,4, or 8.
        ///     gl.UNPACK_FLIP_Y_WEBGL                  Flips the source data along its vertical axis when texImage2D or texSubImage2D are called when param is true. The initial value for param is false.
        ///     gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL       Multiplies the alpha channel, if it exists, into the other color channels during the data transfer when texImage2D or texSubImage2D are called when param is true. The initial value for param is false.
        ///     gl.UNPACK_COLORSPACE_CONVERSION_WEBGL   The browser's default colorspace conversion is applied when texImage2D or texSubImage2D are called with an HTMLImageElement texture data source. The initial value for param is BROWSER_DEFAULT_WEBGL. No colorspace conversion is applied when set to NONE.
        /// </param>
        /// <param name="param">Values depend on value of pname.</param>
        public virtual void PixelStorei(int pName, bool param) { }

        /// <summary>
        /// Sets the implementation-specific units and scale factor used to calculate fragment depth values.
        /// </summary>
        /// <param name="factor">The scale factor. Initial value is 0.</param>
        /// <param name="units">Number that's multiplied by an implementation-specific value to get a constant depth offset. Initial value is 0.</param>
        public virtual void PolygonOffset(double factor, double units) { }

        /// <summary>
        /// Reads pixel data into an ArrayBufferView object from a rectangular area in the color buffer of the active frame buffer.
        /// If an error is generated, no change is made to data object referenced by the pixels parameter.
        ///
        /// Errors:
        ///
        ///     gl.INVALID_ENUM                        If format or type aren't accepted values.
        ///
        ///     gl.INVALID_VALUE                    If height or width are negative numbers.
        ///                                         If pixels is null.
        ///
        ///     gl.INVALID_OPERATION                If format isn't gl.RGBA and type isn't
        ///     gl.UNSIGNED_BYTE                    If pixels isn't large enough for the pixel data.
        ///
        ///     gl.INVALID_FRAMEBUFFER_OPERATION    If the currently bound frame buffer isn't complete or the render frame buffer is invalid.
        /// </summary>
        /// <param name="x">Horizontal coordinate of the first pixel to read in the lower left corner of rectangle. </param>
        /// <param name="y">Vertical coordinate of the first pixel to read in the lower left corner of rectangle. </param>
        /// <param name="width">Width of the rectangle.</param>
        /// <param name="height">Height of the rectangle.</param>
        /// <param name="format">Format of the pixel data. For example, gl.RGBA.</param>
        /// <param name="type">Describes the type of data being read:
        ///    gl.UNSIGNED_BYTE
        ///    gl.FLOAT         Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">Object to read data into. One of the following types:
        ///     Uint8Array when used without extensions.
        ///     Float32Array when using the OES_texture_float extension .
        /// </param>
        public virtual void ReadPixels(int x, int y, int width, int height, int format, int type, Uint8Array pixels) { }

        /// <summary>
        /// Reads pixel data into an ArrayBufferView object from a rectangular area in the color buffer of the active frame buffer.
        /// If an error is generated, no change is made to data object referenced by the pixels parameter.
        ///
        /// Errors:
        ///
        ///     gl.INVALID_ENUM                        If format or type aren't accepted values.
        ///
        ///     gl.INVALID_VALUE                    If height or width are negative numbers.
        ///                                         If pixels is null.
        ///
        ///     gl.INVALID_OPERATION                If format isn't gl.RGBA and type isn't
        ///     gl.UNSIGNED_BYTE                    If pixels isn't large enough for the pixel data.
        ///
        ///     gl.INVALID_FRAMEBUFFER_OPERATION    If the currently bound frame buffer isn't complete or the render frame buffer is invalid.
        /// </summary>
        /// <param name="x">Horizontal coordinate of the first pixel to read in the lower left corner of rectangle. </param>
        /// <param name="y">Vertical coordinate of the first pixel to read in the lower left corner of rectangle. </param>
        /// <param name="width">Width of the rectangle.</param>
        /// <param name="height">Height of the rectangle.</param>
        /// <param name="format">Format of the pixel data. For example, gl.RGBA.</param>
        /// <param name="type">Describes the type of data being read:
        ///    gl.UNSIGNED_BYTE
        ///    gl.FLOAT         Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">Object to read data into. One of the following types:
        ///     Uint8Array when used without extensions.
        ///     Float32Array when using the OES_texture_float extension .
        /// </param>
        public virtual void ReadPixels(int x, int y, int width, int height, int format, int type, Float32Array pixels) { }

        /// <summary>
        /// Creates or replaces the data store for the currently bound WebGLRenderbuffer object.
        ///
        /// Errors:
        ///     gl.INVALID_ENUM            If target is not gl.RENDERBUFFER.
        ///                             If internal format is not one of the listed formats.
        ///
        ///     gl.INVALID_VALUE        If width and height are greater than gl.MAX_RENDERBUFFER_SIZE or less than zero.
        ///     gl.INVALID_OPERATION    The renderbuffer object isn't bound to a gl.RENDERBUFFER object.
        ///     gl.OUT_OF_MEMORY        The data store couldn't be generated with the supplied width and height.
        /// </summary>
        /// <param name="target">Target must be the constant gl.RENDERBUFFER.</param>
        /// <param name="internalFormat">One of the following values:
        ///     gl.RGBA4                RGBA with 4 bits per channel
        ///     gl.RGB565               RGB value with 5 bits red, 6 bits green, and 5 bits blue respectively.
        ///     gl.RGB5_A1              RGBA value with 5 bits for RGB and 1 bit for Alpha.
        ///     gl.DEPTH_COMPONENT16    16 bit Depth component.
        /// </param>
        /// <param name="width">Width of the render buffer in pixels.</param>
        /// <param name="height">Height of the render buffer in pixels.</param>
        public virtual void RenderbufferStorage(int target, int internalFormat, int width, int height) { }

        /// <summary>
        /// Sets multi-sample coverage parameters for antialiasing.
        /// If no multi-sample buffers exist or multi-sampling is disabled, then final RGB colors are computed with a single sample.
        /// </summary>
        /// <param name="value">A floating point number between 0 and 1 that determines sample coverage. Used to temporarily create a mask to determine which samples are used for the final fragment color.</param>
        /// <param name="invert">True if the coverage mask bits are inverted and a bitwise and is used, false otherwise. </param>
        public virtual void SampleCoverage(double value, bool invert) { }

        /// <summary>
        /// Sets the dimensions of the scissor box.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    Either width or height is a negative value.
        /// </summary>
        /// <param name="x">The horizontal coordinate for the lower left corner of the box. Initially 0. </param>
        /// <param name="y">The vertical coordinate for the lower left corner of the box. Initially 0. </param>
        /// <param name="width">The width of the scissor box. For a WebGL context attached to a canvas, this value is the width of the canvas.</param>
        /// <param name="height">The height of the scissor box. For a WebGL context attached to a canvas, this value is the height of the canvas.</param>
        public virtual void Scissor(int x, int y, int width, int height) { }

        /// <summary>
        /// Sets and replaces shader source code in a shader object.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If shader isn't a WebGL object or value.
        ///     gl.INVALID_OPERATION    If shader isn't a WebGLShader object.
        /// </summary>
        /// <param name="shader">The shader object to set the source code on. </param>
        /// <param name="source">GLSL source code.</param>
        public virtual void ShaderSource(WebGLShader shader, string source) { }

        /// <summary>
        /// Sets the front and back function and reference value for stencil testing.
        /// Any parameter values set via stencilFunc are set on both the front and back-facing stencil buffers.
        /// The reference and mask values are stored in integer format and any float portion of the values are truncated.
        /// Only the least significant n bits of the mask value are stored (where n is the size of the stencil buffer in bits).
        /// The stencilFunc parameters (that is, STENCIL_FUNC and STENCIL_REF) can be set when the stencil test is disabled or a stencil buffer is not available, but will have no impact during rendering.
        /// Calling stencilFunc with an invalid stencilFunc enumeration value generates the INVALID_ENUM error but doesn’t affect any previously-set parameter value.
        /// </summary>
        /// <param name="func">Specifies the test function. The stencil functions for the front and back-facing stencil buffers (whose parameter names are STENCIL_FUNC and STENCIL_BACK_FUNC, respectively) default to ALWAYS.</param>
        /// <param name="reference">Specifies the reference value for the stencil test. ref is clamped to the range [0, 2(n - 1)], where n is the number of stencil bits for both the front and back-facing stencil bits. The stencil reference values for the front and back-facing stencil buffers (respectively STENCIL_REF and STENCIL_BACK_REF) default to 0.</param>
        /// <param name="mask">Specifies a mask that is bit-wise ANDed with both the reference value and the stored stencil value when the test is done. The initial stencil value masks for the front and back-facing stencil buffers (respectively STENCIL_VALUE_MASK and STENCIL_BACK_VALUE_MASK) default to an unsigned integer which has the n least significant bits set all to 1s (where n is the size of the stencil buffer in bits). </param>
        public virtual void StencilFunc(int func, int reference, int mask) { }

        /// <summary>
        /// Sets the front and/or back function and reference value for stencil testing.
        /// Write operations on the front-facing stencil buffer do not affect the contents of the back-facing stencil buffer (and vice-versa).
        /// You can set the same stencil function on both the front and back-facing stencil buffers by calling stencilFuncSeparate with face set to FRONT_AND_BACK.
        /// Calling stencilFuncSeparate with an invalid face enumeration value generates the INVALID_ENUM error code.
        /// Calling stencilFuncSeparate with an invalid func enumeration value generates the INVALID_ENUMerror code and doesn’t affect any previously set parameter value on either the front or back-facing stencil buffers.
        /// Different stencil reference and mask values can be set on the front and back-facing stencil buffers without generating an error, but attempting to render generates the INVALID_OPERATION error and does not affect the contents of the WebGL viewport.
        /// </summary>
        /// <param name="face">Specifies whether front and/or back stencil state is updated.</param>
        /// <param name="func">Specifies the test function. The initial value is ALWAYS</param>
        /// <param name="reference">Specifies the reference value for the stencil test. ref is clamped to the range [0, 2(n - 1)], where n is the number of stencil bits for both the front and back-facing stencil bits. The stencil reference values for the front and back-facing stencil buffers (respectively STENCIL_REF and STENCIL_BACK_REF) default to 0.</param>
        /// <param name="mask">Specifies a mask that is bit-wise ANDed with both the reference value and the stored stencil value when the test is done. The initial value is composed entirely of 1's.</param>
        public virtual void StencilFuncSeparate(int face, int func, int reference, int mask) { }

        /// <summary>
        /// Controls the front and back writing of individual bits in the stencil planes.
        /// The stencil write mask can be used to control writing to the stencil buffer during both rendering and clear operations.
        /// Only the n least significant bits of the mask parameter value are saved (where n is the size of the stencil buffer in bits).
        /// The write mask value is set on both the front and back stencil buffers.
        /// The write mask value can be set when the stencil test is disabled or a stencil buffer is unavailable.
        /// The write mask defaults to an integer which has the n least significant bits set to all 1s on both the front and back-facing stencil buffers.
        /// </summary>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, this mask composed entirely of 1's.</param>
        public virtual void StencilMask(int mask) { }

        /// <summary>
        /// Controls the front and/or back writing of individual bits in the stencil planes.
        /// Different write masks can be set on the front and back-facing stencil buffers, but attempting to render will generate the INVALID_OPERATION error and does not affect the contents of the WebGL viewport.
        /// Stencil buffer boundary regions can be written to (that is, corner areas).
        /// The stencil buffer isn’t modified when a rendering error occurs.
        /// Stencil buffer values are clamped to the range [0, 2(n - 1)], where n is the size of the stencil buffer (in bits).
        /// </summary>
        /// <param name="face">Specifies whether the front and/or back stencil write mask is updated.</param>
        /// <param name="mask">Specifies a bit mask to enable and disable writing of individual bits in the stencil planes. Initially, the mask is composed entirely of 1's.</param>
        public virtual void StencilMaskSeparate(int face, int mask) { }

        /// <summary>
        /// Sets front and back stencil test actions.
        /// The parameters set via stencilOp are set on both the front and back-facing stencil buffers.
        /// The parameters set via stencilOp default to KEEP for both the front and back-facing stencil buffers.
        /// The stencilOp parameters can be set when the stencil test is disabled or a stencil buffer is unavailable.
        /// </summary>
        /// <param name="fail">Specifies the action to take when the stencil test fails.</param>
        /// <param name="zfail">Specifies the stencil action when the stencil test passes, but the depth test fails. This parameter is ignored when the depth buffer or depth test are disabled.</param>
        /// <param name="zpass">Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled.</param>
        public virtual void StencilOp(int fail, int zfail, int zpass) { }

        /// <summary>
        /// Sets front and/or back stencil test actions.
        /// </summary>
        /// <param name="face">Specifies whether front and/or back stencil state is updated.</param>
        /// <param name="fail">Specifies the action to take when the stencil test fails.</param>
        /// <param name="zfail">Specifies the stencil action when the stencil test passes, but the depth test fails. This parameter is ignored when the depth buffer or depth test are disabled.</param>
        /// <param name="zpass">Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil test passes and either there is no depth buffer or depth testing is not enabled.</param>
        public virtual void StencilOpSeparate(int face, int fail, int zfail, int zpass) { }

        /// <summary>
        /// Loads the supplied pixel data into a texture.
        /// When using an ArrayBufferView for pixels and gl.FLOAT for type, the array must be a Float32Array rather than a UInt8Array.
        /// Images that are used as textures are not allowed if the origin of the image isn't the same as the origin of the canvas element. Images are also blocked if they are from a canvas whose origin-clean flag set to false.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR             Occurs if an image or canvas is supplied as the pixel data source and isn't the same origin (same domain) of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_OPERATION        If the ArrayBufferView doesn't have enough data to fill the specified rectangle.
        ///                                 If format and internalformat don't match.
        ///                                 No texture is bound to target.
        ///                                 If type is gl.UNSIGNED_SHORT_5_6_5 and format isn't gl.RGB.
        ///                                 If type is gl.UNSIGNED_SHORT_4_4_4_4 or gl.UNSIGNED_SHORT_5_5_5_1 and the format isn't gl.RGBA
        ///
        ///     gl.INVALID_VALUE            target is a cube map target and width and height aren't equal.
        ///                                 If pixels is null for any of the non-ArrayBuffer overloads.
        ///                                 The incoming ArrayBufferView or image is bigger than max texture size. Max texture can be retrieved by calling getParameter and using the gl.MAX_CUBE_MAP_TEXTURE_SIZE and gl.MAX_TEXTURE_SIZE enums.
        ///                                 If level, width, or height is a negative value.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not a cube map texture target.
        ///
        ///     gl.INVALID_ENUM                If target, format, internalformat, or type aren't one of the listed values.
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail value. </param>
        /// <param name="internalFormat">
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="width">Width of texture image. Value used only when UInt8Array or Float32Array for pixels is specified.</param>
        /// <param name="height">Height of texture image. Value used only when UInt8Array or Float32Array for pixels is specified.</param>
        /// <param name="border">Specifies the width of the border. Must be 0. Border value used only when UInt8Array or Float32Array for pixels is specified.</param>
        /// <param name="format">Contains the format for the source pixel data. Must match internalformat. </param>
        /// <param name="type">The type of texture data.
        ///     gl.UNSIGNED_BYTE                Provides 8 bits per channel for gl.RGBA.
        ///     gl.FLOAT                        Call getExtension("gl.OES_texture_float") first to enable. This creates 128 bit-per-pixel textures instead of 32 bit-per-pixel for the image.
        ///     gl.UNSIGNED_SHORT_5_6_5         Represents colors in a Uint16Array where red = 5 bits, green=6 bits, and blue=5 bits.
        ///     gl.UNSIGNED_SHORT_4_4_4_4       Represents colors in a Uint16Array where red = 4 bits, green=4 bits, blue=4 bits, and alpha=4 bits.
        ///     gl.UNSIGNED_SHORT_5_5_5_1       Represents colors in a Uint16Array where red = 5 bits, green=5 bits, blue=5 bits and alpha=1 bit.</param>
        /// <param name="pixels">The ArrayBufferView to use as a data source for the texture. A buffer of sufficient size is automatically allocated and its contents is initialized to 0 if pixels is null.</param>
        public virtual void TexImage2D(int target, int level, int internalFormat, int width, int height, int border, int format, int type, ArrayBufferView pixels) { }

        /// <summary>
        /// Loads the supplied pixel data into a texture.
        /// Images that are used as textures are not allowed if the origin of the image isn't the same as the origin of the canvas element. Images are also blocked if they are from a canvas whose origin-clean flag set to false.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR             Occurs if an image or canvas is supplied as the pixel data source and isn't the same origin (same domain) of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_OPERATION        If the ArrayBufferView doesn't have enough data to fill the specified rectangle.
        ///                                 If format and internalformat don't match.
        ///                                 No texture is bound to target.
        ///                                 If type is gl.UNSIGNED_SHORT_5_6_5 and format isn't gl.RGB.
        ///                                 If type is gl.UNSIGNED_SHORT_4_4_4_4 or gl.UNSIGNED_SHORT_5_5_5_1 and the format isn't gl.RGBA
        ///
        ///     gl.INVALID_VALUE            target is a cube map target and width and height aren't equal.
        ///                                 If pixels is null for any of the non-ArrayBuffer overloads.
        ///                                 The incoming ArrayBufferView or image is bigger than max texture size. Max texture can be retrieved by calling getParameter and using the gl.MAX_CUBE_MAP_TEXTURE_SIZE and gl.MAX_TEXTURE_SIZE enums.
        ///                                 If level, width, or height is a negative value.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not a cube map texture target.
        ///
        ///     gl.INVALID_ENUM                If target, format, internalformat, or type aren't one of the listed values.
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail value. </param>
        /// <param name="internalFormat">
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="format">Contains the format for the source pixel data. Must match internalformat. </param>
        /// <param name="type">The type of texture data.
        ///     gl.UNSIGNED_BYTE                Provides 8 bits per channel for gl.RGBA.
        ///     gl.FLOAT                        Call getExtension("gl.OES_texture_float") first to enable. This creates 128 bit-per-pixel textures instead of 32 bit-per-pixel for the image.
        ///     gl.UNSIGNED_SHORT_5_6_5         Represents colors in a Uint16Array where red = 5 bits, green=6 bits, and blue=5 bits.
        ///     gl.UNSIGNED_SHORT_4_4_4_4       Represents colors in a Uint16Array where red = 4 bits, green=4 bits, blue=4 bits, and alpha=4 bits.
        ///     gl.UNSIGNED_SHORT_5_5_5_1       Represents colors in a Uint16Array where red = 5 bits, green=5 bits, blue=5 bits and alpha=1 bit.</param>
        /// <param name="pixels">The CanvasElement to use as a data source for the texture. A buffer of sufficient size is automatically allocated and its contents is initialized to 0 if pixels is null.</param>
        public virtual void TexImage2D(int target, int level, int internalFormat, int format, int type, HTMLCanvasElement pixels) { }

        /// <summary>
        /// Loads the supplied pixel data into a texture.
        /// Images that are used as textures are not allowed if the origin of the image isn't the same as the origin of the canvas element. Images are also blocked if they are from a canvas whose origin-clean flag set to false.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR             Occurs if an image or canvas is supplied as the pixel data source and isn't the same origin (same domain) of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_OPERATION        If the ArrayBufferView doesn't have enough data to fill the specified rectangle.
        ///                                 If format and internalformat don't match.
        ///                                 No texture is bound to target.
        ///                                 If type is gl.UNSIGNED_SHORT_5_6_5 and format isn't gl.RGB.
        ///                                 If type is gl.UNSIGNED_SHORT_4_4_4_4 or gl.UNSIGNED_SHORT_5_5_5_1 and the format isn't gl.RGBA
        ///
        ///     gl.INVALID_VALUE            target is a cube map target and width and height aren't equal.
        ///                                 If pixels is null for any of the non-ArrayBuffer overloads.
        ///                                 The incoming ArrayBufferView or image is bigger than max texture size. Max texture can be retrieved by calling getParameter and using the gl.MAX_CUBE_MAP_TEXTURE_SIZE and gl.MAX_TEXTURE_SIZE enums.
        ///                                 If level, width, or height is a negative value.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not a cube map texture target.
        ///
        ///     gl.INVALID_ENUM                If target, format, internalformat, or type aren't one of the listed values.
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail value. </param>
        /// <param name="internalFormat">
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="format">Contains the format for the source pixel data. Must match internalformat. </param>
        /// <param name="type">The type of texture data.
        ///     gl.UNSIGNED_BYTE                Provides 8 bits per channel for gl.RGBA.
        ///     gl.FLOAT                        Call getExtension("gl.OES_texture_float") first to enable. This creates 128 bit-per-pixel textures instead of 32 bit-per-pixel for the image.
        ///     gl.UNSIGNED_SHORT_5_6_5         Represents colors in a Uint16Array where red = 5 bits, green=6 bits, and blue=5 bits.
        ///     gl.UNSIGNED_SHORT_4_4_4_4       Represents colors in a Uint16Array where red = 4 bits, green=4 bits, blue=4 bits, and alpha=4 bits.
        ///     gl.UNSIGNED_SHORT_5_5_5_1       Represents colors in a Uint16Array where red = 5 bits, green=5 bits, blue=5 bits and alpha=1 bit.</param>
        /// <param name="pixels">The ImageElement to use as a data source for the texture. A buffer of sufficient size is automatically allocated and its contents is initialized to 0 if pixels is null.</param>
        public virtual void TexImage2D(int target, int level, int internalFormat, int format, int type, HTMLImageElement pixels) { }

        /// <summary>
        /// Loads the supplied pixel data into a texture.
        ///
        /// Images that are used as textures are not allowed if the origin of the image isn't the same as the origin of the canvas element. Images are also blocked if they are from a canvas whose origin-clean flag set to false.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR             Occurs if an image or canvas is supplied as the pixel data source and isn't the same origin (same domain) of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_OPERATION        If the ArrayBufferView doesn't have enough data to fill the specified rectangle.
        ///                                 If format and internalformat don't match.
        ///                                 No texture is bound to target.
        ///                                 If type is gl.UNSIGNED_SHORT_5_6_5 and format isn't gl.RGB.
        ///                                 If type is gl.UNSIGNED_SHORT_4_4_4_4 or gl.UNSIGNED_SHORT_5_5_5_1 and the format isn't gl.RGBA
        ///
        ///     gl.INVALID_VALUE            target is a cube map target and width and height aren't equal.
        ///                                 If pixels is null for any of the non-ArrayBuffer overloads.
        ///                                 The incoming ArrayBufferView or image is bigger than max texture size. Max texture can be retrieved by calling getParameter and using the gl.MAX_CUBE_MAP_TEXTURE_SIZE and gl.MAX_TEXTURE_SIZE enums.
        ///                                 If level, width, or height is a negative value.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_TEXTURE_SIZE when target is gl.TEXTURE_2D.
        ///                                 If level is greater than log 2(max), where max is the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not gl.TEXTURE_2D.
        ///                                 If width or height are greater than the value of gl.MAX_CUBE_MAP_TEXTURE_SIZE when target is not a cube map texture target.
        ///
        ///     gl.INVALID_ENUM                If target, format, internalformat, or type aren't one of the listed values.
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail value. </param>
        /// <param name="internalFormat">
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="format">Contains the format for the source pixel data. Must match internalformat. </param>
        /// <param name="type">The type of texture data.
        ///     gl.UNSIGNED_BYTE                Provides 8 bits per channel for gl.RGBA.
        ///     gl.FLOAT                        Call getExtension("gl.OES_texture_float") first to enable. This creates 128 bit-per-pixel textures instead of 32 bit-per-pixel for the image.
        ///     gl.UNSIGNED_SHORT_5_6_5         Represents colors in a Uint16Array where red = 5 bits, green=6 bits, and blue=5 bits.
        ///     gl.UNSIGNED_SHORT_4_4_4_4       Represents colors in a Uint16Array where red = 4 bits, green=4 bits, blue=4 bits, and alpha=4 bits.
        ///     gl.UNSIGNED_SHORT_5_5_5_1       Represents colors in a Uint16Array where red = 5 bits, green=5 bits, blue=5 bits and alpha=1 bit.</param>
        /// <param name="pixels">The ImageData array to use as a data source for the texture. A buffer of sufficient size is automatically allocated and its contents is initialized to 0 if pixels is null.</param>
        public virtual void TexImage2D(int target, int level, int internalFormat, int format, int type, ImageData pixels) { }

        /// <summary>
        /// Sets texture parameters for the current texture unit.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    If no texture is bound.
        ///     gl.INVALID_ENUM            If target, pname, or param values are invalid.
        /// </summary>
        /// <param name="target">The target texture for the current texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D           Represents a 2D image.
        ///     gl.TEXTURE_CUBE_MAP     The texture is composed of six 2D images, one for each face of a cube.
        /// </param>
        /// <param name="pName">The name of the texture parameter. Use one of the following:
        ///     gl.TEXTURE_MIN_FILTER           A texture filter constant to use when a surface is rendered smaller than the corresponding texture bitmap (such as for distant objects). Initial value is gl.NEAREST_MIPMAP_LINEAR.
        ///     gl.TEXTURE_MAG_FILTER           A texture filter constant to use when a surface is rendered larger than the corresponding texture bitmap (such as for close-up objects). Initial value is gl.LINEAR.
        ///     gl.TEXTURE_WRAP_S               Sets the wrap parameter for texture coordinate s to either gl.CLAMP or gl.REPEAT. gl.CLAMP causes s coordinates to be clamped to the range [0,1] and is useful for preventing wrapping artifacts when mapping a single image onto an object. gl.REPEAT causes the integer part of the s coordinate to be ignored; WebGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to gl.CLAMP. Initially, gl.TEXTURE_WRAP_S is set to gl.REPEAT.
        ///     gl.TEXTURE_WRAP_T               Sets the wrap parameter for texture coordinate t to either gl.CLAMP or gl.REPEAT. Initial value is gl.REPEAT.
        ///     gl.TEXTURE_MAX_ANISOTROPY_EXT   Use anisotropic filtering. You must call getExtension("gl.TEXTURE_MAX_ANISOTROPY_EXT") first to enable. For more info, see Anisotropic filtering.
        /// </param>
        /// <param name="param">The value of pname. The value of param depends on the value of pname.
        /// When using floating-point textures, only gl.NEAREST is supported. The following shows possible calling values:
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
        /// </param>
        public virtual void TexParameterf(int target, int pName, int param) { }

        /// <summary>
        /// Sets texture parameters for the current texture unit.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    If no texture is bound.
        ///     gl.INVALID_ENUM            If target, pname, or param values are invalid.
        /// </summary>
        /// <param name="target">The target texture for the current texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D           Represents a 2D image.
        ///     gl.TEXTURE_CUBE_MAP     The texture is composed of six 2D images, one for each face of a cube.
        /// </param>
        /// <param name="pName">The name of the texture parameter. Use one of the following:
        ///     gl.TEXTURE_MIN_FILTER           A texture filter constant to use when a surface is rendered smaller than the corresponding texture bitmap (such as for distant objects). Initial value is gl.NEAREST_MIPMAP_LINEAR.
        ///     gl.TEXTURE_MAG_FILTER           A texture filter constant to use when a surface is rendered larger than the corresponding texture bitmap (such as for close-up objects). Initial value is gl.LINEAR.
        ///     gl.TEXTURE_WRAP_S               Sets the wrap parameter for texture coordinate s to either gl.CLAMP or gl.REPEAT. gl.CLAMP causes s coordinates to be clamped to the range [0,1] and is useful for preventing wrapping artifacts when mapping a single image onto an object. gl.REPEAT causes the integer part of the s coordinate to be ignored; WebGL uses only the fractional part, thereby creating a repeating pattern. Border texture elements are accessed only if wrapping is set to gl.CLAMP. Initially, gl.TEXTURE_WRAP_S is set to gl.REPEAT.
        ///     gl.TEXTURE_WRAP_T               Sets the wrap parameter for texture coordinate t to either gl.CLAMP or gl.REPEAT. Initial value is gl.REPEAT.
        ///     gl.TEXTURE_MAX_ANISOTROPY_EXT   Use anisotropic filtering. You must call getExtension("gl.TEXTURE_MAX_ANISOTROPY_EXT") first to enable. For more info, see Anisotropic filtering.
        /// </param>
        /// <param name="param">The value of pname. The value of param depends on the value of pname.
        /// When using floating-point textures, only gl.NEAREST is supported. The following shows possible calling values:
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
        ///     texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT)
        /// </param>
        public virtual void TexParameteri(int target, int pName, int param) { }

        /// <summary>
        /// Replaces a portion of an existing 2D texture image with all of another image.
        /// When using an ArrayBufferView for pixels and gl.FLOAT for type, the array must be a Float32Array rather than a UInt8Array.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR         Occurs if an image or canvas is supplied and doesn't have the same origin of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_VALUE        If pixels is null.
        ///                             If level is &lt; 0, or greater than maximum allowable value.
        ///                             If xoffset is greater than the width of the texture image.
        ///                             If yoffset is greater than the height of the texture image.
        ///
        ///     gl.INVALID_OPERATION    If called without a currently bound texture.
        ///                             The type doesn't match the type originally defined for the texture.
        ///                             If type and format aren't compatible values.
        ///
        ///     gl.INVALID_ENUM            If target, format, or type aren't one of the listed values.
        ///
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail to use with the texture.</param>
        /// <param name="xOffset">The x (horizontal) offset within the texture image.</param>
        /// <param name="yOffset">The y (vertical) offset within the texture image.</param>
        /// <param name="width">Width of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="height">Height of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="format">The format of the source pixel data.
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="type">The data type of the pixel data.
        ///     gl.UNSIGNED_BYTE
        ///     gl.FLOAT            Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">The ArrayBufferView to use for the texture.</param>
        public virtual void TexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, ArrayBufferView pixels) { }

        /// <summary>
        /// Replaces a portion of an existing 2D texture image with all of another image.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR         Occurs if an image or canvas is supplied and doesn't have the same origin of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_VALUE        If pixels is null.
        ///                             If level is &lt; 0, or greater than maximum allowable value.
        ///                             If xoffset is greater than the width of the texture image.
        ///                             If yoffset is greater than the height of the texture image.
        ///
        ///     gl.INVALID_OPERATION    If called without a currently bound texture.
        ///                             The type doesn't match the type originally defined for the texture.
        ///                             If type and format aren't compatible values.
        ///
        ///     gl.INVALID_ENUM            If target, format, or type aren't one of the listed values.
        ///
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail to use with the texture.</param>
        /// <param name="xOffset">The x (horizontal) offset within the texture image.</param>
        /// <param name="yOffset">The y (vertical) offset within the texture image.</param>
        /// <param name="width">Width of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="height">Height of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="format">The format of the source pixel data.
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="type">The data type of the pixel data.
        ///     gl.UNSIGNED_BYTE
        ///     gl.FLOAT            Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">The CanvasElement to use for the texture.</param>
        public virtual void TexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, HTMLCanvasElement pixels) { }

        /// <summary>
        /// Replaces a portion of an existing 2D texture image with all of another image.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR         Occurs if an image or canvas is supplied and doesn't have the same origin of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_VALUE        If pixels is null.
        ///                             If level is &lt; 0, or greater than maximum allowable value.
        ///                             If xoffset is greater than the width of the texture image.
        ///                             If yoffset is greater than the height of the texture image.
        ///
        ///     gl.INVALID_OPERATION    If called without a currently bound texture.
        ///                             The type doesn't match the type originally defined for the texture.
        ///                             If type and format aren't compatible values.
        ///
        ///     gl.INVALID_ENUM            If target, format, or type aren't one of the listed values.
        ///
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail to use with the texture.</param>
        /// <param name="xOffset">The x (horizontal) offset within the texture image.</param>
        /// <param name="yOffset">The y (vertical) offset within the texture image.</param>
        /// <param name="width">Width of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="height">Height of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="format">The format of the source pixel data.
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="type">The data type of the pixel data.
        ///     gl.UNSIGNED_BYTE
        ///     gl.FLOAT            Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">The ImageElement to use for the texture.</param>
        public virtual void TexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, HTMLImageElement pixels) { }

        /// <summary>
        /// Replaces a portion of an existing 2D texture image with all of another image.
        ///
        /// Errors:
        ///     gl.SECURITY_ERR         Occurs if an image or canvas is supplied and doesn't have the same origin of the canvas associated with the WebGLRenderingContext.
        ///
        ///     gl.INVALID_VALUE        If pixels is null.
        ///                             If level is &lt; 0, or greater than maximum allowable value.
        ///                             If xoffset is greater than the width of the texture image.
        ///                             If yoffset is greater than the height of the texture image.
        ///
        ///     gl.INVALID_OPERATION    If called without a currently bound texture.
        ///                             The type doesn't match the type originally defined for the texture.
        ///                             If type and format aren't compatible values.
        ///
        ///     gl.INVALID_ENUM            If target, format, or type aren't one of the listed values.
        ///
        /// </summary>
        /// <param name="target">The target texture of the active texture unit. Must be one of the following:
        ///     gl.TEXTURE_2D                       Uses a 2D image.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_X      Image for the positive X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_X      Image for the negative X face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Y      Image for the positive Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Y      Image for the negative Y face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_POSITIVE_Z      Image for the positive Z face of the cube map.
        ///     gl.TEXTURE_CUBE_MAP_NEGATIVE_Z      Image for the negative Z face of the cube map.
        /// </param>
        /// <param name="level">The level of detail to use with the texture.</param>
        /// <param name="xOffset">The x (horizontal) offset within the texture image.</param>
        /// <param name="yOffset">The y (vertical) offset within the texture image.</param>
        /// <param name="width">Width of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="height">Height of texture sub-image. Value used only when UInt8Array or Float32Array for pixels is specified. </param>
        /// <param name="format">The format of the source pixel data.
        ///     gl.ALPHA                Each element is a single alpha component. The system converts it to floating point, clamped to the range [0, 1], and assembles it into an RGBA element by placing attaching 0.0 to the red, green and blue channels.
        ///     gl.LUMINANCE            Each element is a single luminance component. The system converts it to floating point value, clamped to the range [0, 1], and assembles it into an RGBA element by placing the luminance value in the red, green and blue channels, and attaching 1.0 to the alpha channel.
        ///     gl.LUMINANCE_ALPHA      Each element is an luminance/alpha double. The systems converts each component to floating point, clamped to the range [0, 1], and assembles them into an RGBA element by placing the luminance value in the red, green and blue channels.
        ///     gl.RGB                  Red, green, and blue channels.
        ///     gl.RGBA                 Red, green, blue, and alpha (transparency) channels.
        /// </param>
        /// <param name="type">The data type of the pixel data.
        ///     gl.UNSIGNED_BYTE
        ///     gl.FLOAT            Call getExtension("gl.OES_texture_float") first to enable. This creates 128bit-per-pixel textures instead of 32bit-per-pixel for the image. </param>
        /// <param name="pixels">The ImageData array to use for the texture.</param>
        public virtual void TexSubImage2D(int target, int level, int xOffset, int yOffset, int width, int height, int format, int type, ImageData pixels) { }

        /// <summary>
        /// Assigns a floating point value to a uniform variable for the current program object.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    There's no active program object.
        ///                             The size and type of the uniform variable doesn't match the size and type of the value loaded.
        /// </summary>
        /// <param name="location">The location:
        ///     null        Data passed will fail silently, no uniform variables will be changed.
        ///     location    Specifies the location of the uniform to modify. WebGLUniformLocation instance returned by getUniformLocation.
        /// </param>
        /// <param name="x">The new floating point value for the uniform variable. </param>
        public virtual void Uniform1f(WebGLUniformLocation location, double x) { }

        /// <summary>
        /// Assigns a floating point vector array to a uniform vector variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        /// The expected behavior when the uniform being updated is an array, the length of 'values' is a multiple of the number of required vector components, and the length of 'values' is either greater than or less than the number of elements in the uniform array (the elements in the uniform array which contain corresponding elements in the 'value' array are updated and no error is generated)
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             Length of the value array is greater than 1 and the uniform pointed to by location isn't a uniform array.
        ///                             value references a typed array instance other than Float32Array.
        ///                             Uniform specified by location isn't a float type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location:
        ///     null        Data passed will fail silently, no uniform variables will be changed.
        ///     string      Location of uniform variable to be changed.
        /// </param>
        /// <param name="value">The new floating point vector array for the uniform variable. </param>
        public virtual void Uniform1fv(WebGLUniformLocation location, double[] value) { }

        /// <summary>
        /// Assigns an integer value to a uniform variable for the current program object.
        /// Uniform1i can be used to set texture samplers. If location is a texture sampler, then value refers to an offset into the array of active textures.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no current program object.
        ///                             If location is an invalid location for the current program object and location isn't equal to -1.
        /// </summary>
        /// <param name="location">Specifies the location of the uniform to modify.</param>
        /// <param name="value">The new value for the uniform variable. </param>
        public virtual void Uniform1i(WebGLUniformLocation location, int value) { }

        /// <summary>
        /// Assigns a boolean value to a uniform variable for the current program object.
        /// Uniform1i can be used to set texture samplers. If location is a texture sampler, then value refers to an offset into the array of active textures.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no current program object.
        ///                             If location is an invalid location for the current program object and location isn't equal to -1.
        /// </summary>
        /// <param name="location">Specifies the location of the uniform to modify.</param>
        /// <param name="value">The new value for the uniform variable. </param>
        public virtual void Uniform1i(WebGLUniformLocation location, bool value) { }

        /// <summary>
        /// Assigns an integer vector array value to a uniform variable for the current program object.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no current program object.
        ///                             If location is an invalid location for the current program object and location isn't equal to -1.
        /// </summary>
        /// <param name="location">The location of the uniform to modify.</param>
        /// <param name="value">An Integer array of data for the uniform. </param>
        public virtual void Uniform1iv(WebGLUniformLocation location, int[] value) { }

        /// <summary>
        /// Assigns two dimensional floating point values to a uniform variable for the current program object.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no current program object.
        ///                             If location is an invalid location for the current program object and location isn't equal to -1.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated. </param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        public virtual void Uniform2f(WebGLUniformLocation location, double x, double y) { }

        /// <summary>
        /// Assigns two dimensional floating point vector array to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             value references a typed array instance other than Float32Array.
        ///                             Uniform specified by location isn't a float type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Two dimensional floating point array to assign.</param>
        public virtual void Uniform2fv(WebGLUniformLocation location, double[][] value) { }

        /// <summary>
        /// Assigns two dimensional integer value to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no current program object.
        ///                             If location is an invalid location for the current program object and location isn't equal to -1.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        public virtual void Uniform2i(WebGLUniformLocation location, int x, int y) { }

        /// <summary>
        /// Assigns two dimensional integer vector array values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION        The location doesn't belong to the current program.
        ///                                 There is no current program object.
        ///                                 If location is an invalid location for the current program object and location isn't equal to -1.
        ///                                 value references a typed array instance other than Float32Array.
        ///                                 Uniform specified by location isn't a float type.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Two dimensional ingeter array to assign.</param>
        public virtual void Uniform2iv(WebGLUniformLocation location, int[][] value) { }

        /// <summary>
        /// Assigns three dimensional floating point values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             Uniform specified by location isn't a float type.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        /// <param name="z">Depth value to assign.</param>
        public virtual void Uniform3f(WebGLUniformLocation location, double x, double y, double z) { }

        /// <summary>
        /// Assigns three dimensional floating point vector array values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             value references a typed array instance other than Float32Array.
        ///                             Uniform specified by location isn't a float type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Three dimensional floating point array to assign.</param>
        public virtual void Uniform3fv(WebGLUniformLocation location, double[][][] value) { }

        /// <summary>
        /// Assigns three dimensional integer values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             Uniform specified by location isn't an integer type.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        /// <param name="z">Depth value to assign.</param>
        public virtual void Uniform3i(WebGLUniformLocation location, int x, int y, int z) { }

        /// <summary>
        /// Assigns three dimensional integer vector array values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             value references a typed array instance other than Int32Array
        ///                             Uniform specified by location isn't an in type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Three dimensional integer array to assign.</param>
        public virtual void Uniform3iv(WebGLUniformLocation location, int[][][] value) { }

        /// <summary>
        /// Assigns four dimensional floating point values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             Uniform specified by location isn't a float type.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        /// <param name="z">Depth value to assign.</param>
        /// <param name="w">Scaling value to assign.</param>
        public virtual void Uniform4f(WebGLUniformLocation location, double x, double y, double z, double w) { }

        /// <summary>
        /// Assigns four dimensional floating point vector array values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             value references a typed array instance other than Float32Array.
        ///                             Uniform specified by location isn't a float type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Four dimensional floating point array to assign.</param>
        public virtual void Uniform4fv(WebGLUniformLocation location, double[][][][] value) { }

        /// <summary>
        /// Assigns four dimensional integer values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             Uniform specified by location isn't an integer type.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="x">Horizontal value to assign.</param>
        /// <param name="y">Vertical value to assign.</param>
        /// <param name="z">Depth value to assign.</param>
        /// <param name="w">Scaling value to assign.</param>
        public virtual void Uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) { }

        /// <summary>
        /// Assigns four dimensional integer vector array values to a uniform variable for the current program object.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             value references a typed array instance other than Int32Array.
        ///                             Uniform specified by location isn't an integer type.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the number of required components.
        /// </summary>
        /// <param name="location">The location of the uniform variable to be updated.</param>
        /// <param name="value">Four dimensional integer array to assign.</param>
        public virtual void Uniform4iv(WebGLUniformLocation location, int[][][][] value) { }

        /// <summary>
        /// Sets values for a 2x2 floating point vector matrix into a uniform location as a matrix or a matrix array.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             The passed in uniform location isn't a matrix of the required dimensions.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the required matrix element count.
        ///                             If transpose equals gl.TRUE.
        /// </summary>
        /// <param name="location">The location of uniform variable to be updated. Locate set by getUniformLocation.</param>
        /// <param name="transpose">Sets whether to transpose the matrix as the values are loaded into the uniform variable. Must be set to gl.FALSE.</param>
        /// <param name="value">An array of float values representing one or more 2x2 matrices.</param>
        public virtual void UniformMatrix2fv(WebGLUniformLocation location, bool transpose, Array value) { }

        /// <summary>
        /// Sets values for a 3x3 floating point vector matrix into a uniform location as a matrix or a matrix array.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             The passed in uniform location isn't a matrix of the required dimensions.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the required matrix element count.
        ///                             If transpose equals gl.TRUE.
        /// </summary>
        /// <param name="location">The location of uniform variable to be updated. Locate set by getUniformLocation.</param>
        /// <param name="transpose">Sets whether to transpose the matrix as the values are loaded into the uniform variable. Must be set to gl.FALSE.</param>
        /// <param name="value">An array of float values representing one or more 3x3 matrices.</param>
        public virtual void UniformMatrix3fv(WebGLUniformLocation location, bool transpose, Array value) { }

        /// <summary>
        /// Sets values for a 4x4 floating point vector matrix into a uniform location as a matrix or a matrix array.
        /// If the location is null, no uniforms are updated and no error code is generated.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    The location doesn't belong to the current program.
        ///                             There is no active program.
        ///                             The passed in uniform location isn't a matrix of the required dimensions.
        ///
        ///     gl.INVALID_VALUE        The length of value array isn't a multiple of the required matrix element count.
        ///                             If transpose equals gl.TRUE.
        /// </summary>
        /// <param name="location">The location of uniform variable to be updated. Locate set by getUniformLocation.</param>
        /// <param name="transpose">Sets whether to transpose the matrix as the values are loaded into the uniform variable. Must be set to gl.FALSE.</param>
        /// <param name="value">An array of float values representing one or more 3x3 matrices.</param>
        public virtual void UniformMatrix4fv(WebGLUniformLocation location, bool transpose, Array value) { }

        /// <summary>
        /// Set the program object to use for rendering.
        /// Program objects can be used for multiple rendering contexts.
        ///
        /// Errors:
        ///     gl.INVALID_OPERATION    If program hasn't been linked.
        ///                             If program isn't a WebGLProgram object, but is a WebGL generated object.
        ///
        ///     gl.INVALID_VALUE        If program isn't a WebGL generated object.
        /// </summary>
        /// <param name="program">The program object.</param>
        public virtual void UseProgram(WebGLProgram program) { }

        /// <summary>
        /// Returns whether a given program can run in the current WebGL state.
        /// A program is considered invalid if it hasn't successfully linked, or any two active samplers in the program are different types, but refer to the same texture image unit.
        /// This method is used in conjunction with getProgramParameter called with gl.VALIDATE_STATUS to test for a valid program.
        /// </summary>
        /// <param name="program">The program to validate.</param>
        public virtual void ValidateProgram(WebGLProgram program) { }

        /// <summary>
        /// Specifies the data formats and locations of attributes in a vertex attributes array.
        /// The method can specify UNSIGNED_BYTE, BYTE, SHORT and UNSIGNED_SHORT for both normalized and un-normalized formats (all component types, 1 through 4, are supported) in Internet Explorer 11 using WebGL renderer version 0.93 and later.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE        If size isn't between 1 and 4.
        ///                             If stride is negative.
        ///                             If offset is negative.
        ///
        ///     gl.INVALID_OPERATION    If stride or offset are not a multiple of type.
        ///                             If no WebGL array buffer is bound.
        ///
        ///     gl.INVALID_ENUM            If type isn't an accepted value.
        /// </summary>
        /// <param name="index">Index of target attribute in the buffer bound to gl.ARRAY_BUFFER. </param>
        /// <param name="size">The number of components per attribute. Must be 1,2,3,or 4. Default is 4.</param>
        /// <param name="type">Specifies the data type of each component in the array. Use one of the following values: gl.FLOAT (default), gl.FIXED</param>
        /// <param name="normalized">false - values are converted to fixed point values when accessed.
        /// true - values are normalized when accessed.</param>
        /// <param name="stride">Specifies the offset in bytes between the beginning of consecutive vertex attributes. Default value is 0, maximum is 255. Must be a multiple of type.</param>
        /// <param name="offset">Specifies an offset in bytes of the first component of the first vertex attribute in the array. Default is 0 which means that vertex attributes are tightly packed. Must be a multiple of type.</param>
        public virtual void VertexAttribPointer(int index, int size, int type, bool normalized, int stride, int offset) { }

        /// <summary>
        /// Represents a rectangular viewable area that contains the rendering results of the drawing buffer.
        ///
        /// Errors:
        ///     gl.INVALID_VALUE    If the width or height is negative.
        /// </summary>
        /// <param name="x">The horizontal component of the viewport origin. Default is 0.</param>
        /// <param name="y">The vertical component of the viewport origin. Default is 0.</param>
        /// <param name="width">The width of the viewport. Default equals the width of the parent canvas.</param>
        /// <param name="height">The height of the viewport. Default equals the height of the parent canvas.</param>
        public virtual void Viewport(int x, int y, int width, int height) { }
    }
}